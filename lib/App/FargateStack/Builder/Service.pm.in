package App::FargateStack::Builder::Service;

use strict;
use warnings;

use Carp;
use Data::Dumper;
use English qw(-no_match_vars);
use List::Util qw(any);

use App::FargateStack::Constants;

use Role::Tiny;

########################################################################
sub build_service {
########################################################################
  my ( $self, $service_name, $desired_count ) = @_;

  my ( $config, $dryrun, $tasks, $cluster ) = $self->common_args(qw(config dryrun tasks cluster));

  my $ecs = $self->fetch_ecs;

  my @vpc_subnets = $self->get_service_subnets;

  my @services = @{ $ecs->list_services( $cluster->{name}, 'serviceArns' ) || [] };

  my @desired_services = $service_name ? ($service_name) : keys %{$tasks};

  $self->log_warn( 'service: creating %d service(s) [%s]', scalar(@desired_services), join q{,}, @desired_services );

  foreach my $task_name (@desired_services) {

    my $task = $tasks->{$task_name};

    if ( any { $_ eq $task_name } @services ) {
      $self->get_logger->info( sprintf 'service: [%s] already exists...skipping', $task_name );
      next;
    }

    $self->get_logger->info( sprintf 'service: creating service: [%s] with [%s] task(s) in subnets: [%s]...%s',
      $task_name, $desired_count, ( join q{,}, @vpc_subnets ), $dryrun );

    if ( !$dryrun ) {
      my $result = $ecs->create_service(
        service_name    => $task_name,
        container_name  => $task_name,
        cluster_name    => $config->{cluster}->{name},
        task_definition => $task_name,
        desired_count   => $desired_count,
        subnets         => \@vpc_subnets,
        security_groups => [ $config->{security_groups}->{fargate}->{group_id} ],
        $self->get_http         ? ( target_group_arn => $task->{target_group_arn} )   : (),
        $task->{container_port} ? ( container_port   => 0 + $task->{container_port} ) : (),
      );

      $self->log_debug( sub { return Dumper( [ result => $result ] ); } );

      $ecs->check_result( { message => 'ERROR: could not create service: [%s], desired count: [%s]' },
        $task_name, $desired_count );
    }
  }

  return;
}

########################################################################
# if we have an ALB we must put the service in those AZs
########################################################################
sub get_service_subnets {
########################################################################
  my ( $self, ) = @_;

  my ( $config, $alb ) = $self->common_args(qw(config alb));

  my $alb_arn = defined $alb && $alb->{arn};

  if ($alb_arn) {
    $self->get_logger->warn('service: service will be placed in the same AZs as load balancer.');
    return $self->get_alb_subnets($alb_arn);
  }

  my $subnets = $self->get_subnets->{private};

  if ( !$subnets || !@{$subnets} ) {
    if ( $subnets = $self->get_subnets->{public} ) {
      $self->get_logger->warn('service: no private subnets! Using public subnets is not recommended.');
    }
    else {
      croak sprintf "no subnets in %s found\n", $config->{vpc_id};
    }
  }

  return @{$subnets}[ 0, 1 ];
}

########################################################################
sub get_alb_subnets {
########################################################################
  my ( $self, $alb_arn ) = @_;

  my $elb = $self->fetch_elbv2;

  my $query = 'LoadBalancers[].AvailabilityZones[].SubnetId';

  my $subnet_ids = $elb->describe_load_balancers( query => $query, arn => $alb_arn );

  $elb->check_result( message => 'ERROR: could not describe load balancer: [%s]', $alb_arn );

  return @{$subnet_ids};
}

1;
