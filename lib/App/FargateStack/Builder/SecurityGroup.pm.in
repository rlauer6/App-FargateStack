package App::FargateStack::Builder::SecurityGroup;

use strict;
use warnings;

use Carp;
use Data::Dumper;
use English qw(-no_match_vars);

use App::Events;
use App::FargateStack::Constants;

use Role::Tiny;

########################################################################
sub build_security_group {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $dryrun = $self->get_dryrun;

  my $ec2 = $self->get_ec2;

  $config->{security_groups} //= {};

  my $security_group_name = $config->{security_groups}->{fargate}->{group_name}
    // $config->{app}->{name} . '-sg';

  $config->{security_groups}->{fargate}->{group_name} = $security_group_name;

  my ($security_group) = $ec2->describe_security_group($security_group_name);

  if ( !$security_group ) {
    $self->get_logger->info( sprintf 'security-group: [%s] will create security group...%s',
      $security_group_name, $dryrun );

    $self->inc_required_resources( security_groups => [$security_group_name] );

    if ( !$dryrun ) {
      my $description = sprintf 'Security group for %s Fargate tasks', $config->{app}->{name};

      my $security_group_id = $ec2->create_security_group( $security_group_name, $description );
      $config->{security_groups}->{fargate}->{group_id} = $security_group_id;

      # authorize ingress when/if we have an ALB
      $self->get_logger->info( sprintf 'security-group: [%s] id: [%s] created',
        $security_group_name, $security_group_id );
    }
  }
  else {
    $config->{security_groups}->{fargate}->{group_id} = $security_group->{GroupId};

    $self->get_logger->info( sprintf 'security-group: [%s] exists...skipping', $security_group_name );

    $self->inc_existing_resources( security_groups => [ $security_group->{GroupId} ] );
  }

  return;
}

1;
