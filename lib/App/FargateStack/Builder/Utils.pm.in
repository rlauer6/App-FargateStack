package App::FargateStack::Builder::Utils;

use strict;
use warnings;

BEGIN {
  use Log::Log4perl;
  Log::Log4perl->wrapper_register(__PACKAGE__);
}

use Carp;
use Data::Dumper;
use English qw(no_match_vars);
use JSON;
use List::Util qw(any none);
use Scalar::Util qw(reftype);
use Time::Piece;
use Time::HiRes qw(time);
use Text::Diff;
use JSON;

use Role::Tiny;
use parent qw(Exporter Class::Accessor::Fast);

__PACKAGE__->follow_best_practice;
__PACKAGE__->mk_accessors(qw(_var_pool));

our @EXPORT = qw(
  ToCamelCase
  choose
  common_args
  confirm
  display_diffs
  dmp
  elapsed_time
  jmespath_mapping
  log_die
  toCamelCase
  slurp_file
  write_json_file
  fetch_ecr
  fetch_ec2
  fetch_ecs
  fetch_ecr
  fetch_elbv2
  fetch_events
  fetch_efs
  fetch_iam
  fetch_logs
  fetch_secrets
  fetch_sts
  fetch_route53
  fetch_cli_api
);

########################################################################
sub fetch_iam     { return shift->fetch_cli_api( 'IAM',     @_ ); }
sub fetch_logs    { return shift->fetch_cli_api( 'Logs',    @_ ); }
sub fetch_efs     { return shift->fetch_cli_api( 'EFS',     @_ ); }
sub fetch_ecs     { return shift->fetch_cli_api( 'ECS',     @_ ); }
sub fetch_ec2     { return shift->fetch_cli_api( 'EC2',     @_ ); }
sub fetch_ecr     { return shift->fetch_cli_api( 'ECR',     @_ ); }
sub fetch_events  { return shift->fetch_cli_api( 'Events',  @_ ); }
sub fetch_sts     { return shift->fetch_cli_api( 'STS',     @_ ); }
sub fetch_secrets { return shift->fetch_cli_api( 'Secrets', @_ ); }
sub fetch_elbv2   { return shift->fetch_cli_api( 'ElbV2',   @_ ); }
sub fetch_route53 { return shift->fetch_cli_api( 'Route53', @_ ); }
########################################################################
sub fetch_cli_api {
########################################################################
  my ( $self, $api, %options ) = @_;

  my $class = $self->get( lc $api );

  return $class
    if $class && !keys %options;

  if ( !$class ) {
    my $class_path = sprintf 'App/%s.pm', $api;

    require $class_path;

    my $class_name = sprintf 'App::%s', $api;

    $self->set( lc $api, $class_name->new( %{ $self->get_global_options }, %options ) );

    $class = $self->get( lc $api );
  }
  else {
    if ( keys %options ) {
      foreach ( keys %options ) {
        $class->set( $_, $options{$_} );
      }
    }
  }

  return $class;
}

########################################################################
sub create_default {
########################################################################
  my ( $self, $what, @args ) = @_;

  require App::FargateStack::Constants;

  croak "no default for $what\n"
    if !exists $App::FargateStack::Constants::DEFAULT_NAMES{$what};

  my $default = $App::FargateStack::Constants::DEFAULT_NAMES{$what};

  return ref $default ? $default->( $self, @args ) : $default;
}

########################################################################
sub confirm {
########################################################################
  my ( $prompt, @args ) = @_;

  print sprintf "$prompt [y/N] ", @args;

  chomp( my $answer = <> );

  return $answer =~ /^y(es)?$/xsmi;
}

########################################################################
sub common_args {
########################################################################
  my ( $self, @args ) = @_;

  my $config = $self->get_config;

  my $var_pool = {
    config => $config,
    cache  => $self->get_cache,
    dryrun => $self->get_dryrun,
    # these just avoid a bunch of hash digging
    tasks           => $config->{tasks},
    cluster         => $config->{cluster},
    security_groups => $config->{security_groups},
    route53         => $config->{route53},
    alb             => $config->{alb},
    app             => $config->{app},
    subnets         => $config->{subnets},
    role            => $config->{role},
    events_role     => $config->{events_role},
  };

  $self->set__var_pool($var_pool);

  return $var_pool
    if !@args;

  my @invalid_args = grep { !exists $var_pool->{$_} } @args;

  croak sprintf "invalid argument(s): %s\n", join q{,}, @invalid_args
    if @invalid_args;

  return @{$var_pool}{@args};
}

########################################################################
sub display_diffs {
########################################################################
  my ( $self, $old, $new, $options ) = @_;

  my $json = JSON->new->canonical->pretty->convert_blessed;

  my $old_str = $json->encode($old);

  my $new_str = $json->encode($new);

  my $diffs = diff( \$old_str, \$new_str );

  return $diffs
    if !$options || !ref $options;

  my ( $title, $log_level ) = @{$options}{qw(title log_level)};

  $log_level //= 'error';

  $title //= 'objects differ:';
  $self->get_logger->$log_level( sprintf "\t%s", $title );
  $self->get_logger->$log_level( sprintf "\t%s", $diffs );

  return $diffs;
}

########################################################################
sub ToCamelCase { goto &_toCamelCase; }
sub toCamelCase { return _toCamelCase( $_[0], $_[1], 1 ); }
########################################################################
sub _toCamelCase {
########################################################################
  my ( $snake_case, $want_hash, $lc_first ) = @_;

  $want_hash //= wantarray ? 0 : 1;

  my @CamelCase = map {
    ( $want_hash ? $_ : (), join q{}, map {ucfirst} split /_/xsm )
  } @{$snake_case};

  return $want_hash ? {@CamelCase} : @CamelCase
    if !$lc_first;

  return map {lcfirst} @CamelCase
    if !$want_hash;

  my %camelCase = @CamelCase;

  %camelCase = map { $_ => lcfirst $camelCase{$_} } keys %camelCase;

  return \%camelCase;
}

########################################################################
sub jmespath_mapping {
########################################################################
  my ( $prefix, $elems, $ucfirst ) = @_;
  $ucfirst //= 0;

  my $hash_list = reftype($elems) eq 'HASH' ? $elems : $ucfirst ? ToCamelCase($elems) : toCamelCase($elems);

  my $list = sprintf '%s.%s', $prefix, encode_json $hash_list;

  $list =~ s/"//gxsm;

  return $list;
}

########################################################################
sub elapsed_time {
########################################################################
  my ($start_time) = @_;

  return q{-}
    if !$start_time;

  # Extract timestamp and offset
  my ( $date, $time, $sign, $h_offset, $m_offset ) = $start_time =~ m{
    ^(\d{4}-\d{2}-\d{2})         # date
    T(\d{2}:\d{2}:\d{2})         # time
    \.\d+                        # fractional seconds
    ([+-])(\d{2}):(\d{2})$       # offset
}x;

  # Parse local time (as in the string, which is relative to its own offset)
  my $tp = Time::Piece->strptime( "$date $time", '%Y-%m-%d %H:%M:%S' );

  # Calculate total offset in seconds
  my $offset_sec = ( $h_offset * 3600 + $m_offset * 60 ) * ( $sign eq '+' ? 1 : -1 );

  # Convert to UTC epoch (add offset to local time to get UTC)
  my $epoch_utc = $tp->epoch - $offset_sec;

  # Get current UTC time
  my $now = time;

  # Elapsed time in seconds
  my $elapsed = int( $now - $epoch_utc );

  # Break into minutes and seconds
  my $minutes = int( $elapsed / 60 );
  my $seconds = $elapsed % 60;

  return sprintf '%d:%02d', $minutes, $seconds;
}

########################################################################
sub choose (&) { return $_[0]->(); }
########################################################################

########################################################################
sub dmp { return print {*STDERR} Dumper( [@_] ); }
########################################################################

########################################################################
sub _inc {
########################################################################
  my ( $what, $self, $key, $value ) = @_;

  my $resources = $self->get($what) // {};

  if ( ref $value && reftype($value) eq 'ARRAY' ) {
    ($value) = @{$value};
    $resources->{$key} //= [];
    push @{ $resources->{$key} }, $value;
  }
  else {
    $resources->{$key} = $value;
  }

  $self->set( $what, $resources );

  return $resources;
}

########################################################################
sub inc_existing_resources {
########################################################################
  return _inc( 'existing_resources', @_ );
}

########################################################################
sub inc_required_resources {
########################################################################
  return _inc( 'required_resources', @_ );
}

########################################################################
sub write_json_file {
########################################################################
  my ( $self, $file, $obj ) = @_;

  open my $fh, '>', $file
    or croak "could not open $file for writing\n";

  my $json = JSON->new->pretty->encode($obj);

  print {$fh} $json;

  close $fh;

  return $json;
}

########################################################################
sub slurp_file {
########################################################################
  my ( $file, $json ) = @_;

  local $RS = undef;

  open my $fh, '<', $file
    or croak "could not open $file\n";

  my $content = <$fh>;

  close $fh;

  return $json ? decode_json($content) : $content;
}

########################################################################
sub section_break { return shift->get_logger->info( q{-} x 80 ) }
########################################################################

########################################################################
sub normalize_name {
########################################################################
  my ( $self, $name ) = @_;

  return join q{}, map {ucfirst} split /[_-]+/xsm, $name;
}

########################################################################
sub is_service_running {
########################################################################
  my ( $self, $task_name ) = @_;

  my ( $config, $cluster ) = $self->common_args(qw(config cluster));
  my $cluster_name = $cluster->{name};

  my $ecs = $self->fetch_ecs;

  my $services = $ecs->list_services( $cluster_name, 'serviceArns' );

  croak sprintf "ERROR: could not list services for: [%s]\n%s", $cluster_name, $ecs->get_error
    if !$services;

  return
    if none {/\/$task_name/xsm} @{$services};

  my $status = $ecs->describe_services(
    cluster_name => $cluster_name,
    service_name => $task_name,
    query        => 'services[0].runningCount'
  );

  croak sprintf "ERROR: could not describe services for: [%s/%s]\n%s", $cluster_name, $task_name, $ecs->get_error
    if !defined $status;

  return $status;
}

########################################################################
sub _log {
########################################################################
  my ( $logger, $level, @args ) = @_;

  # If first arg looks like a sprintf format string AND we have more args, call sprintf
  if ( @args > 1 && $args[0] =~ /%/xsm ) {
    return $logger->$level( sprintf shift(@args), @args );
  }
  else {
    return $logger->$level(@args);
  }
}

sub log_info  { return _log( shift->get_logger, 'info',  @_ ) }
sub log_debug { return _log( shift->get_logger, 'debug', @_ ) }
sub log_warn  { return _log( shift->get_logger, 'warn',  @_ ) }
sub log_error { return _log( shift->get_logger, 'error', @_ ) }
sub log_die   { exit _log( shift->get_logger, 'error', @_ ) || 1; }
sub log_trace { return _log( shift->get_logger, 'trace', @_ ) }
sub log_fatal { return _log( shift->get_logger, 'fatal', @_ ) }

1;
