package App::FargateStack::Builder::IAM;

use strict;
use warnings;

use Carp;
use Data::Dumper;
use Data::Compare;
use English qw(-no_match_vars);

use App::FargateStack::Constants;
use App::FargateStack::Builder::Utils qw(log_die choose);

use Role::Tiny;

########################################################################
sub build_iam_role {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $dryrun = $self->get_dryrun;

  my $tasks = $config->{tasks};

  my $iam = $self->fetch_iam;

  my $default_name = $self->normalize_name( $config->{app}->{name} );

  my $role_name = $self->create_fargate_role($default_name);

  my $policy_name = $config->{policy_name};
  $policy_name //= sprintf 'Fargate%sPolicy', $default_name;

  my $policy;
  my $role_policy;

  # NOTE: we may need to invalidate the role by removing the ARN and
  # forcing the role policy to be replaced. 'put-role-policy' will
  # allow overwriting a policy with the same name.

  if ( !$self->get_cache || !$config->{role}->{arn} || !$config->{role}->{policy_name} ) {
    $policy = $iam->get_role_policy( $role_name, $policy_name );

    if ($policy) {
      $config->{role}->{policy_name} = $policy_name;
    }

    my @statement;

    $role_policy = {
      Version   => $IAM_POLICY_VERSION,
      Statement => \@statement,
    };

    push @statement, $self->add_ecr_policy();

    push @statement, $self->add_efs_policy();  # force rebuild of policy

    push @statement, $self->add_log_group_policy();

    if ( $config->{bucket} ) {
      push @statement, $self->add_bucket_policy;
    }

    if ( $config->{queue} ) {
      push @statement, $self->add_queue_policy();
    }

    if ( my $secrets = $self->get_secrets ) {
      push @statement, $self->add_secrets_policy($secrets);
    }
  }

  if ( $config->{role}->{arn} ) {
    if ( ( $policy && Compare( $policy, $role_policy ) ) || $self->get_cache ) {
      $self->log_info( 'iam:policy [%s] exists...%s', $policy_name, $self->get_cache || 'skipping' );
      $self->inc_existing_resources( 'iam:role-policy' => [$policy_name] );
      return;
    }

    $self->log_trace(
      sub {
        return Dumper(
          [ existing_policy => $policy,
            new_policy      => $role_policy
          ]
        );
      }
    );

    $self->log_warn( 'iam:policy [%s] will be replaced...%s', $policy_name, $dryrun );
  }

  $self->inc_required_resources( 'iam:policy' => [$policy_name] );

  return
    if $dryrun;

  if ($policy) {
    $self->log_warn( 'iam:policy: deleting policy [%s] for role [%s]...', $policy_name, $role_name );
    $iam->delete_role_policy( $role_name, $policy_name );
  }

  $self->log_warn( 'iam:policy: creating policy [%s] for role [%s]...', $policy_name, $role_name );

  $iam->put_role_policy( $role_name, $policy_name, $role_policy );

  $self->log_trace( sub { return Dumper( [ 'iam:policy' => $role_policy ] ); } );

  log_die( $self, "ERROR: could not create policy %s for %s\n%s", $role_name, $policy_name, $iam->get_error )
    if $iam->get_error;

  return;
}

########################################################################
sub create_fargate_role { return shift->create_role( @_, 'ecs-tasks' ); }
########################################################################

########################################################################
sub create_role {
########################################################################
  my ( $self, $default_name, $type ) = @_;

  my $config = $self->get_config;

  my $dryrun = $self->get_dryrun;

  my $iam = $self->fetch_iam;

  my $trust_policy = {
    Version   => $IAM_POLICY_VERSION,
    Statement => [
      { Effect    => 'Allow',
        Principal => { Service => $AWS_SERVICE_DOMAINS{$type} },
        Action    => 'sts:AssumeRole'
      }
    ]
  };

  my $role_config = sub {
    if ( $type eq 'events' ) {
      $config->{events_role} //= {};
      return $config->{events_role};
    }
    else {
      $config->{role} //= {};
      return $config->{role};
    }
    }
    ->();

  my $role_name = $role_config->{name};

  $role_name //= sprintf '%s%sRole', ( $type eq 'events' ? 'Events' : 'Fargate' ), $default_name;
  $role_config->{name} = $role_name;

  my $role = choose {
    return { Role => { Arn => $role_config->{arn} } }
      if $self->get_cache && $role_config->{arn};

    return $iam->role_exists($role_name);
  };

  $self->log_trace( sub { return Dumper( [ role => $role ] ) } );

  if ( $role->{Role}->{Arn} ) {
    $self->log_info( 'iam: role [%s] exists...%s', $role_name, $self->get_cache || 'skipping' );

    $role_config->{arn} = $role->{Role}->{Arn};
    $self->inc_existing_resources( 'iam:role' => [ $role->{Role}->{Arn} ] );

    return $role_name;
  }

  $self->inc_required_resources(
    'iam:role' => [
      sub {
        my ($dryrun) = @_;
        return $dryrun ? "arn:???/$role_name" : $role_config->{arn};
      }
    ]
  );

  $self->log_warn( 'iam: [%s] will be created...%s', $role_name, $self->get_dryrun );

  if ( !$dryrun ) {
    $role_config->{arn} = $iam->create_role( $role_name, $trust_policy );

    $self->log_trace( sub { return Dumper( [ 'iam: policy' => $trust_policy ] ); } );

    log_die( $self, "ERROR: could not create role: %s\n%s", $role_name, $iam->get_error )
      if $iam->get_error;
  }

  return $role_name;
}

########################################################################
sub fetch_iam {
########################################################################
  my ($self) = @_;

  require App::IAM;

  my $iam = $self->get_iam;

  return $iam
    if $iam;

  $iam = App::IAM->new( $self->get_global_options );

  $self->set_iam($iam);

  return $iam;
}

1;
