package App::FargateStack::CreateStack;

use strict;
use warnings;

use App::FargateStack::Builder::Utils qw(log_die);
use App::FargateStack::Constants;
use CLI::Simple::Constants qw(:booleans :chars);
use Carp;
use Data::Dumper;
use English qw(-no_match_vars);
use File::Basename qw(basename);
use YAML qw(Dump);

use Role::Tiny;

########################################################################
sub cmd_create_stack {
########################################################################
  my ($self) = @_;

  my ( $app_name, @args ) = $self->get_args;

  croak sprintf "ERROR: app names should only have a-z_-0-9 characters\n"
    if lc $app_name !~ /\A[[:lower:]\d_-]+\z/xsm;

  my $sts = $self->fetch_sts;

  my $account = $sts->get_caller_identity('Account');

  my $config = {
    account => $account,
    profile => $self->get_profile,
    region  => $self->get_region,
    app     => { name => $app_name },
  };

  my %tasks;

  while ( my $tag = shift @args ) {

    if ( $tag =~ /^(daemon|task|scheduled|https?):/xsm ) {
      $tasks{$tag} = [];

      while ( my $next_tag = shift @args ) {
        if ( $next_tag =~ /^(?:daemon|task|scheduled|https?):/xsm ) {
          unshift @args, $next_tag;
          last;
        }
        push @{ $tasks{$tag} }, $next_tag;
      }
    }
  }

  foreach my $t ( keys %tasks ) {
    my ( $type, $name ) = split /[:]/xsm, $t;
    $self->log_info( 'create-stack: configuring: %s %s', $type, $name );

    my @options = @{ $tasks{$t} };

    my $task = { type => $type eq 'scheduled' ? 'task' : $type };
    $config->{tasks}->{$name} = $task;

    my ($image) = grep {/^image:/xsm} @options;

    croak sprintf "ERROR: task [%s] does not have an image...every task must have an image\n", $name
      if !$image;

    my ($image_name) = $image =~ /^image:(.*)$/xsm;

    # If the user omitted a tag, you can optionally default to :latest
    # $image_name .= ':latest' if $image_name !~ /:[^\/]+$/;

    my ( $repo, $tag ) = split /:/xsm, $image_name, 2;
    $tag //= 'latest';

    if ( $image_name !~ m{/}xsm ) {
      # ECR shorthand (repo[:tag]) in current account

      my $ecr    = $self->fetch_ecr;
      my $images = $ecr->describe_images( $repo, 'imageDetails' );

      if ( !$images || !@{$images} ) {
        $self->log_warn( 'create-stack: %s not found in ECR...assuming public image', $image );
        $task->{image} = "$image_name:$tag";  # leave as-is; ECS will try public registries
      }
      else {
        my $uri = sprintf '%s.dkr.ecr.%s.amazonaws.com/%s:%s', $account, $self->get_region, $image_name, $tag;
        $task->{image} = $uri;
      }
    }
    else {
      # Fully-qualified external or cross-account reference; accept as-is
      $task->{image} = "$repo:$tag";
    }

    if ( $t =~ /^scheduled:/xsm ) {
      my ($schedule) = grep {/^schedule:/xsm} @options;

      croak "ERROR: scheduled tasks must have a schedule\n"
        if !$schedule;

      $task->{schedule} = ( split /[:]/xsm, $schedule )[-1];
    }

    if ( $t =~ /^(https?):/xsm ) {
      my ($domain) = grep {/^domain:/xsm} @options;

      croak "ERROR: HTTP and HTTPS services must have a domain\n"
        if !$domain;

      $config->{domain} = ( split /[:]/xsm, $domain )[-1];
    }

    my @environment = grep {/^environment:/xsm} @options;

    foreach (@environment) {
      my ( $key, $value ) = split /\s*=\s*/xsm, ( split /:/xsm )[-1];
      $task->{environment} = { $key => $value };
    }
  }

  print {*STDOUT} Dump($config);

  return;
}

########################################################################
sub resolve_image_name {
########################################################################
  my ( $self, $image_name ) = @_;

  return $image_name
    if $image_name =~ m{/}xsm;

  # ECR shorthand (repo[:tag]) in current account
  my ( $repo, $tag ) = split /:/xsm, $image_name, 2;
  $tag //= 'latest';

  my $ecr    = $self->fetch_ecr;
  my $images = $ecr->describe_images( $repo, 'imageDetails' );

  return $image_name
    if !$images || !@{$images};

  return sprintf '%s.dkr.ecr.%s.amazonaws.com/%s:%s', $self->get_account, $self->get_region, $image_name, $tag;
}

1;
