package App::FargateStack::Builder;

use strict;
use warnings;

use App::FargateStack::Constants;
use App::FargateStack::Builder::Utils qw(log_die confirm);

use CLI::Simple::Constants qw(:booleans);
use Carp;
use Data::Dumper;
use Digest::MD5 qw(md5_hex);
use English qw(-no_match_vars);
use File::Temp qw(tempfile);
use List::Util qw(pairs any none uniq);
use Scalar::Util qw(reftype);
use Text::ASCIITable::EasyTable;
use YAML qw(DumpFile);
use Term::ANSIColor;

use Role::Tiny;

########################################################################
sub build {
########################################################################
  my ($self) = @_;

  $self->benchmark;

  my $config = $self->get_config;

  my $domain = $config->{domain};

  my $subnets = $self->get_subnets();

  $self->section_break;

  # -- task definitions --
  $self->create_taskdef_files;
  $self->section_break;

  # -- log groups --
  # this needs to follow _create_taskdef_files
  $self->build_log_groups;
  $self->benchmark('log-groups');
  $self->section_break;

  # -- certificate --
  if ( $domain && $self->has_https_service ) {
    $self->build_certificate;
    $self->benchmark('certificate');
    $self->section_break;
  }

  # -- queue --
  if ( $config->{queue} && $config->{queue}->{name} ) {
    $self->build_queue;
    $self->benchmark('queue');
    $self->section_break;
  }

  # -- bucket --
  if ( $config->{bucket} && $config->{bucket}->{name} ) {
    $self->build_bucket;
    $self->benchmark('bucket');
    $self->section_break;
  }

  ## -- iam --
  $self->build_iam_role;
  $self->benchmark('iam');
  $self->section_break;

  ## -- cluster --
  $self->build_fargate_cluster;
  $self->benchmark('cluster');
  $self->section_break;

  ## -- security group --
  $self->build_security_group;
  $self->benchmark('security-group');
  $self->section_break;

  # -- task definitions --
  foreach my $task ( keys %{ $config->{tasks} } ) {
    $self->register_task_definition($task);
  }

  $self->benchmark('task-definition');
  $self->section_break;

  ## -- events --
  if ( $self->has_events ) {
    $self->build_events;
    $self->benchmark('events');
    $self->section_break;
  }

  ## -- http service --
  if ( $self->get_http() ) {
    $self->build_http_service;
    $self->benchmark('http-service');
    $self->section_break;
  }

  # -- route53 (create alias)
  if ( $self->get_http ) {
    $self->create_alias();
    $self->benchmark('route53');
    $self->section_break;
  }

  # -- finished --
  $self->log_info( 'builder: build completed in %ds', $self->benchmark('elapsed_time') );

  $self->log_info( 'builder: %d resources will be created.', scalar keys %{ $self->get_required_resources // {} } // 0 );

  $self->log_info( 'builder: %d resources already exist', scalar keys %{ $self->get_existing_resources // {} } // 0 );

  $self->section_break;

  ## -- benchmarks --
  my @benchmarks;
  foreach my $p ( pairs $self->dump_benchmarks() ) {
    push @benchmarks, { Resource => $p->[0], Time => $p->[1] };
  }

  my $table = easy_table(
    columns       => [qw(Resource Time)],
    data          => \@benchmarks,
    table_options => { headingText => 'Benchmarks' },
  );

  $self->log_info("\n$table");

  # -- resources --
  foreach my $p ( pairs Required => $self->get_required_resources, Existing => $self->get_existing_resources ) {

    my $data      = [];
    my $resources = $p->[1];

    foreach my $k ( sort keys %{$resources} ) {
      my $value = resolve_resource_value( $resources->{$k} // $EMPTY, $self->get_dryrun );
      $value = sprintf '%s', join( "\n", @{$value} ) // $EMPTY;

      push @{$data}, { Resource => $k, Value => $value };
    }

    if ( @{$data} ) {
      my $table = easy_table(
        columns       => [qw(Resource Value)],
        data          => $data,
        table_options => { headingText => $p->[0] . ' Resources' }
      );

      my $level = $p->[0] eq 'Required' ? 'warn' : 'info';

      $self->get_logger->$level("\n$table");
    }
    else {
      $self->log_warn( 'builder: no %s resources', lc $p->[0] );
    }
  }

  $self->update_config;

  return;
}

# resolves the resource value from the hash of resources
# TBD: better documentation of this method
########################################################################
sub resolve_resource_value {
########################################################################
  my ( $value, $dryrun ) = @_;

  return [$value]
    if !ref $value;

  if ( reftype($value) eq 'ARRAY' ) {
    my @values;

    foreach my $v ( @{$value} ) {
      if ( ref $v && reftype($v) eq 'CODE' ) {
        push @values, $v->($dryrun);
      }
      else {
        push @values, $v;
      }
    }
    return \@values;
  }
  else {
    return [ $value->($dryrun) ];
  }
}

########################################################################
sub update_config_id {
########################################################################
  my ($self) = @_;

  $Data::Dumper::Sortkeys = $TRUE;

  my $config = $self->get_config;

  delete $config->{id};
  delete $config->{last_updated};

  my $md5_hex = md5_hex( Dumper( $self->get_config ) );

  $config->{id} = $md5_hex;

  $config->{last_updated} = scalar localtime;

  return $config;
}

########################################################################
sub update_config {
########################################################################
  my ($self) = @_;

  $self->log_warn( 'builder: config file %s %s be updated', $self->get_config_name, $self->get_update ? 'will' : 'will not' );

  return
    if !$self->get_update;

  my ( $fh, $filename ) = tempfile( 'fargate-stack-XXXX', SUFFIX => '.yml' );

  my $config = $self->update_config_id();

  DumpFile( $filename, $config );

  my $config_name = $self->get_config_name;

  rename $config_name, "${config_name}.bak";

  rename $filename, $config_name;

  return;
}

########################################################################
sub configure_alb {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $is_secure = $self->has_https_service;

  # default ALB type is private with a listener on port 80
  my $alb_config = $config->{alb} // {};
  $alb_config->{type} //= $is_secure ? 'public' : 'private';
  $alb_config->{port} //= $is_secure ? '443'    : '80';

  # if it was already defined as public w/o a port, then 443 and
  # redirect 80 -> 443
  if ( $alb_config->{type} eq 'public' && !$alb_config->{port} ) {
    $alb_config->{port} = '443';
    if ( !defined $alb_config->{redirect_80} ) {
      $alb_config->{redirect_80} = $TRUE;
    }
  }

  croak "invalid alb type, must be 'public' or 'private'\n"
    if $alb_config->{type} !~ /^public|private$/xsm;

  $config->{alb} = $alb_config;

  return;
}

########################################################################
sub remove_listener_rules {
########################################################################
  my ( $self, $alb_arn ) = @_;

  my ( $config, $dryrun ) = $self->common_args(qw(config dryrun));

  my $elb = $self->get_elbv2;

  my $domain = $config->{domain};

  my $listeners = $elb->describe_listeners( $alb_arn, 'Listeners' );

  foreach my $listener ( @{$listeners} ) {
    my $rules = $elb->describe_rules( $listener->{ListenerArn}, 'Rules' );

    foreach my $rule ( @{$rules} ) {
      my $action     = $rule->{Actions}->[0];
      my $conditions = $rule->{Conditions}->[0] || [];

      next
        if !$conditions;
      next
        if !$conditions->{Field};
      next
        if $conditions->{Field} ne 'host-header';
      next
        if $conditions->{Values}->[0] ne $domain;

      $self->log_warn( 'removing App::FargateStack provisioned listener rule type: [%s] for port: [%s]...%s',
        $action->{Type}, $listener->{Port}, $dryrun );

      if ( !$dryrun ) {
        $elb->delete_rule( $rule->{RuleArn} );
      }

      last;
    }
  }

  return;
}

########################################################################
# type = task|scheduled|daemon|https?
########################################################################
sub delete_task_resources {
########################################################################
  my ( $self, $task_name, $type ) = @_;

  my ( $config, $tasks, $dryrun, $security_groups, $cluster )
    = $self->common_args(qw(config tasks dryrun security_groups cluster));

  $cluster ||= {};
  $cluster->{name} ||= $self->create_default('cluster-name');
  $config->{cluster} = $cluster;

  return $SUCCESS
    if !confirm( sprintf 'Are you sure you want to delete the %s (%s) task?', $task_name, $type );

  # check to see if service is running before removing resources
  my $task_type = $tasks->{$task_name}->{type};

  if ( $task_type =~ /^(?:https?|daemon)$/xsm ) {
    $self->log_trace( sub { return Dumper( [ cluster => $cluster ] ); } );

    log_die( $self, 'ERROR: service [%s] is still running...stop service first.', $task_name )
      if $self->is_service_running($task_name);
  }

  if ( !$dryrun ) {
    $self->log_error('WARNING: "dryrun" mode not enabled...resources will be removed!');
  }

  my $confirm_all = $self->get_confirm_all;

  ######################################################################
  # -- delete log group
  ######################################################################
  $self->_delete_log_group( $confirm_all, $task_name );

  ######################################################################
  # -- delete roles & policies
  ######################################################################
  $self->_delete_roles( $confirm_all, $task_name, $type );

  ######################################################################
  # -- delete scheduled task
  ######################################################################
  if ( $type eq 'scheduled' ) {
    $self->_delete_scheduled_task( $confirm_all, $task_name );
  }

  ######################################################################
  # -- delete task definitions
  ######################################################################
  $self->_delete_task_definitions( $confirm_all, $task_name );

  ######################################################################
  # -- delete service
  ######################################################################

  if ( $type =~ /^(?:daemon|https?)$/xsm ) {
    ####################################################################
    # -- remove alias record
    ####################################################################
    $self->_delete_alias_record($confirm_all);

    $self->_delete_service( $confirm_all, $task_name, $type );
  }

  ######################################################################
  # -- delete http(s)
  ######################################################################
  if ( $type =~ /^(?:https?)$/xsm ) {
    $self->_delete_http( $confirm_all, $task_name );
  }

  ####################################################################
  # -- remove target group
  ####################################################################
  $self->_delete_target_group( $confirm_all, $task_name );

  ######################################################################
  # -- delete security group
  ######################################################################
  $self->_delete_security_group( $confirm_all, $task_name );

  ######################################################################
  # -- delete cluster
  ######################################################################
  $self->_delete_cluster( $confirm_all, $task_name );

  ######################################################################
  # NOTE: Skeletons of deleted tasks are left in the confguration file
  # for single task config and for multi-task configs. --purge-config
  # will allow purging of tasks in multi-task configs only...
  ######################################################################
  if ( $self->get_purge_config ) {
    delete $tasks->{$task_name};
  }

  if ( !$dryrun ) {
    $self->update_config;
  }

  return $SUCCESS;
}

########################################################################
sub _delete_cluster {
########################################################################
  my ( $self, $confirm_all, $service_name, $type ) = @_;

  my ( $config, $dryrun, $tasks ) = $self->common_args(qw(config dryrun tasks));

  my $cluster_name = $config->{cluster}->{name};
  my $confirmed    = $confirm_all ? confirm( 'Delete cluster: [%s]', $cluster_name ) : $TRUE;

  if ($confirmed) {
    my $ecs = $self->fetch_ecs;

    $self->log_warn( 'cluster: [%s] will be deleted...%s', $cluster_name, $dryrun );

    if ( !$dryrun ) {
      $ecs->delete_cluster( $config->{cluster}->{name} );
      $ecs->check_result(
        message => 'ERROR: could not delete cluster: [%s]',
        params  => [$cluster_name],
        regexp  => qr/nosuchentity/xmsi,
      );

      delete $config->{cluster};
    }
  }
  else {
    $self->log_warn( 'cluster deletion skipped...%s', $dryrun );
  }
  return;
}

########################################################################
sub _delete_alias_record {
########################################################################
  my ( $self, $confirm_all, $service_name, $type ) = @_;

  my ( $config, $dryrun, $tasks ) = $self->common_args(qw(config dryrun tasks));
  my $domain = $config->{domain};

  my $confirmed = $confirm_all ? confirm( 'Delete alias record for: [%s]', $domain ) : $TRUE;

  if ($confirmed) {
    $self->log_warn( 'alias record for: [%s] will be deleted...%s', $domain, $dryrun );

    if ( !$dryrun ) {
      $self->remove_alias_record( $config->{alb}->{arn} );
    }
  }
  else {
    $self->log_warn( 'alias record deletion skipped...%s', $dryrun );
  }

  return;
}

########################################################################
sub _delete_service {
########################################################################
  my ( $self, $confirm_all, $service_name, $type ) = @_;

  my ( $config, $dryrun, $tasks ) = $self->common_args(qw(config dryrun tasks));

  my $confirmed = $confirm_all ? confirm( 'Delete %s service?', $type ) : $TRUE;

  if ($confirmed) {

    $self->log_warn( 'Service: [%s] will be deleted...%s', $service_name, $dryrun );

    if ( !$dryrun ) {
      my $ecs = $self->fetch_ecs;

      $ecs->delete_service( $config->{cluster}->{name}, $service_name );

      $ecs->check_result(
        message => 'ERROR: could not delete ECS service: [%s]',
        params  => [$service_name],
        regexp  => qr/notfound/xsmi
      );
    }
  }
  else {
    $self->log_warn( 'service deletion skipped...%s', $dryrun );
  }

  return;
}

########################################################################
sub _delete_task_definitions {
########################################################################
  my ( $self, $confirm_all, $task_name ) = @_;

  my ( $config, $dryrun, $tasks ) = $self->common_args(qw(config dryrun tasks));

  my $confirmed = $confirm_all ? confirm( 'Delete all task definitions for: [%s]', $task_name ) : $TRUE;

  if ($confirmed) {
    my $ecs = $self->fetch_ecs;

    my $task_definitions = $ecs->list_task_definitions( $task_name, 'taskDefinitionArns' );
    $self->log_warn( 'task definitions for: [%s] will be deleted...%s', $task_name, $dryrun );

    if ( !$dryrun ) {
      if ( $task_definitions && @{$task_definitions} ) {
        $ecs->delete_task_definitions($task_definitions);
        $ecs->check_result( message => 'ERROR: could not delete task definitions' );
      }

      $task_definitions = $ecs->list_task_definitions( $task_name, 'taskDefinitionArns' );
      $ecs->check_result( message => 'ERROR: could not list task definitions' );

      # this should happen...delete_task_definitions() will croak if a
      # task definition cannot be deregistered and deleted
      croak "ERROR: could not delete all task definitions\n"
        if @{$task_definitions};

      delete $tasks->{$task_name}->{task_definition_arn};
    }
  }
  else {
    $self->log_warn( 'task definition deletion skipped...%s', $dryrun );
  }
  return;
}

########################################################################
sub _delete_scheduled_task {
########################################################################
  my ( $self, $confirm_all, $task_name, $type ) = @_;

  my ( $config, $dryrun, $tasks ) = $self->common_args(qw(config dryrun tasks));

  ######################################################################
  # -- delete schedule task
  ######################################################################
  my $confirmed = $confirm_all ? confirm( 'Delete scheduled task: [%s]', $task_name ) : $TRUE;

  if ($confirmed) {
    # -- delete target event
    my $events = $self->fetch_events;

    my $rule_name = $self->create_default( 'rule-name', $task_name );
    my $rule_id   = $self->create_default( 'rule-id',   $task_name );

    $self->log_warn( 'scheduled task: [%s] will be deleted...%s', $task_name, $dryrun );

    ####################################################################
    # -- remove target
    ####################################################################
    if ( !$dryrun ) {
      $events->remove_target( $rule_name, $rule_id );
      $events->check_result(
        message => 'ERROR: could not remove target for rule: [%s], id: [%s]',
        params  => [ $rule_name, $rule_id ],
        regexp  => qr/notfound/xsmi
      );

      ####################################################################
      # -- delete rule
      ####################################################################
      $events->delete_rule($rule_name);
      $events->check_result( message => 'ERROR: could not remove rule: [%s]', params => [$rule_name] );
    }
  }
  else {
    $self->log_warn( 'event deletion skipped...%s', $dryrun );
  }

  return;
}

########################################################################
sub _delete_roles {
########################################################################
  my ( $self, $confirm_all, $task_name, $type ) = @_;

  my ( $config, $dryrun ) = $self->common_args(qw(config dryrun));

  my $confirmed = $confirm_all ? confirm( 'Delete roles & policies for task: [%s]?', $task_name ) : $TRUE;

  ######################################################################
  # -- delete roles & policies
  ######################################################################
  if ($confirmed) {

    my $iam = $self->fetch_iam();

    my @roles = ( 'role', $type eq 'scheduled' ? 'events_role' : () );

    foreach my $r (@roles) {
      my $role = $config->{$r};
      my ( $role_name, $policy_name ) = @{$role}{qw(name policy_name)};

      if ( !defined $role_name ) {
        $self->log_warn('role not defined in configuration...skipping deletion');
        delete $role->{arn};
        next;
      }

      ####################################################################
      # -- delete role policy
      ####################################################################
      $self->log_warn( 'role: [%s] and policy: [%s] will be deleted...%s', $role_name, $policy_name, $dryrun );

      if ( !$dryrun ) {
        $iam->delete_role_policy( $role_name, $policy_name );
        $iam->check_result(
          message => 'ERROR: could not delete role policy: [%s]',
          params  => [$policy_name],
          regexp  => qr/nosuchentity/xsmi
        );

        delete $role->{policy_name};

        ####################################################################
        # -- delete role
        ####################################################################
        $iam->delete_role($role_name);
        $iam->check_result(
          message => 'ERROR: could not delete role: [%s]',
          params  => [$role_name],
          regexp  => qr/nosuchentity/xsmi
        );

        delete $role->{name};
        delete $role->{arn};
      }
    }
  }
  else {
    $self->log_warn( 'role & policy deletion skipped...%s', $dryrun );
  }

  return;
}

########################################################################
sub _delete_log_group {
########################################################################
  my ( $self, $confirm_all, $task_name ) = @_;

  my ( $config, $dryrun, $tasks ) = $self->common_args(qw(config dryrun tasks));

  my $log_group = $tasks->{$task_name}->{log_group}->{name};

  if ( !$log_group ) {
    $self->log_warn('log group not defined in configuration file...skipping deletion');
    return;
  }

  my $confirmed = $confirm_all ? confirm( 'Delete log_group: [%s]?', $log_group ) : $TRUE;

  if ( !$confirmed ) {
    $self->log_warn('log group deletion skipped...');
    return;
  }

  my $logs = $self->fetch_logs();

  $self->log_warn( 'log group: [%s] will be deleted...%s', $log_group, $dryrun );

  return
    if $dryrun;

  $logs->delete_log_group($log_group);

  $logs->check_result(
    message => 'ERROR: could not delete log group: %s',
    params  => [$log_group],
    regexp  => qr/notfound/xsmi
  );

  delete $tasks->{$task_name}->{log_group};

  return;
}

########################################################################
sub _delete_security_group {
########################################################################
  my ( $self, $confirm_all, $task_name ) = @_;

  my ( $config, $dryrun, $security_groups, $tasks ) = $self->common_args(qw(config dryrun security_groups tasks));

  my $ec2 = $self->fetch_ec2;

  my $efs_config = $tasks->{$task_name}->{efs};

  my $sg_id = $security_groups->{fargate}->{group_id};

  if ( !$sg_id ) {
    $self->log_warn('no security group defined in configuration...skipping deletion');
    return;
  }

  my $confirmed = $confirm_all ? confirm( 'Delete security_group: [%s]?', $sg_id ) : $TRUE;

  if ($confirmed) {
    if ( $efs_config && $efs_config->{authorize_ingress} ) {
      $self->log_warn( q{fargate task's ingress to EFS will be revoked...%s}, $dryrun );

      if ( !$dryrun ) {
        $self->revoke_efs_ingress( $sg_id, $efs_config->{id} );
      }
    }

    $self->log_warn( 'security group: [%s] will be deleted...%s', $sg_id, $dryrun );

    if ( !$dryrun ) {
      $ec2->delete_security_group($sg_id);

      $ec2->check_result(
        message => 'ERROR: could not delete security_group: %s',
        params  => [$sg_id],
        regexp  => qr/notfound|invalid/xsmi
      );

      delete $security_groups->{fargate};
    }

  }
  else {
    $self->log_warn( 'security group deletion skipped...%s', $dryrun );
  }

  return;
}

########################################################################
sub _delete_target_group {
########################################################################
  my ( $self, $confirm_all, $task_name ) = @_;

  my ( $tasks, $dryrun ) = $self->common_args(qw(tasks dryrun));

  my $elbv2 = $self->fetch_elbv2;

  my $target_group_arn = $tasks->{$task_name}->{target_group_arn};

  if ( !$target_group_arn ) {
    $self->log_warn('no target group defined in configuration...skipping target group deletion');
    return $FALSE;
  }

  my $confirmed = $confirm_all ? confirm( 'Delete target group for task: [%s]', $task_name ) : $TRUE;

  if ($confirmed) {
    $self->log_warn( 'target group for task: [%s] will be removed...%s', $task_name, $dryrun );

    if ( !$dryrun ) {
      $elbv2->delete_target_group($target_group_arn);
      $elbv2->check_result( message => 'could not delete target group: [%s]', params => [$target_group_arn] );

      delete $tasks->{$task_name}->{target_group_arn};
    }
  }
  else {
    $self->log_warn( 'target group deletion skipped...%s', $dryrun );
  }

  return;
}

########################################################################
sub _delete_http {
########################################################################
  my ( $self, $confirm_all, $task_name ) = @_;

  my ( $config, $tasks, $dryrun, $security_groups ) = $self->common_args(qw(config tasks dryrun security_groups));

  my $alb_sg = $security_groups->{alb}->{group_id};

  my $alb_arn = $config->{alb}->{arn};

  if ( !$alb_arn ) {
    $self->log_warn('no ALB  in config...skipping ALB teardown');
    return $FALSE;
  }

  my $target_group_arn = $tasks->{$task_name}->{target_group_arn};

  if ( !$target_group_arn ) {
    $self->log_warn('no target group in config...skipping ALB teardown');
    return $FALSE;
  }

  my $type = $tasks->{$task_name}->{type};

  my $confirmed = $confirm_all ? confirm( 'Delete %s task?', $type ) : $TRUE;

  if ( !$confirmed ) {
    $self->log_warn( 'skipping deletion of %s service', $task_name );

    return;
  }

  ####################################################################
  # -- remove ALB if it was provisioned by App::FargateStack
  ####################################################################
  my $is_our_alb = $self->is_our_alb( $alb_arn, $target_group_arn );

  if ( !$is_our_alb ) {
    my $confirmed = $confirm_all ? confirm( 'Delete listener rules on ALB: [%s]?', $alb_arn ) : $TRUE;

    if ($confirmed) {
      $self->log_warn( 'listener rules for ALB: [%s] will be deleted...%s', $alb_arn, $dryrun );
      $self->remove_listener_rules($alb_arn);
    }
    else {
      $self->log_warn('skipping deletion of listener rules');
    }

    return;
  }

  $confirmed = $confirm_all ? confirm( 'Delete ALB: [%s]?', $alb_arn ) : $TRUE;

  if ($confirmed) {
    $self->log_warn( 'ALB: [%s] and its listener rules will be deleted...%s', $alb_arn, $dryrun );

    if ( !$dryrun ) {
      my $ec2   = $self->fetch_ec2;
      my $elbv2 = $self->fetch_elbv2;

      $elbv2->delete_load_balancer($alb_arn);
      $elbv2->check_result( message => 'could not delete load balancer: [%s]', params => [$alb_arn] );

      if ( $self->wait_for_alb_delete() ) {
        $self->log_warn( 'successfully deleted ALB: [%s]', $alb_arn );

        delete $config->{alb}->{arn};
      }
      else {
        log_die( $self, 'deletion of ALB: [%s] may have failed or has not completed yet.', $alb_arn );
      }

      ####################################################################
      # -- remove security group
      ####################################################################
      $self->log_warn( 'security group for ALB on task: [%s] will be removed...%s', $task_name, $dryrun );
      $ec2->delete_security_group($alb_sg);

      $ec2->check_result(
        message => 'could not delete security group: [%s]',
        params  => [$alb_sg],
        regexp  => qr/notfound/xsmi
      );

      delete $security_groups->{alb};
    }
  }
  else {
    $self->log_warn('skipping deletion of ALB');
  }

  return;
}

########################################################################
sub wait_for_alb_delete {
########################################################################
  my ($self) = @_;

  my $alb_arn = $self->get_config->{alb}->{arn};

  my $tries = $DEFAULT_ALB_MAX_TRIES;

  my $elbv2 = $self->fetch_elbv2;

  while ( $tries-- > 0 ) {
    my $result = $elbv2->describe_load_balancer($alb_arn);
    return $TRUE if !$result && $elbv2->get_error =~ /notfound/xsmi;
    sleep $DEFAULT_ALB_POLL_SLEEP_TIME;
  }

  return $FALSE;
}

########################################################################
sub is_our_alb {
########################################################################
  my ( $self, $alb_arn, $tg_arn ) = @_;

  my $elb = $self->get_elbv2;

  croak "usage: is_our_alb(alb-arn, target-group-arn)\n"
    if !$alb_arn || !$tg_arn;

  my $tags = $elb->describe_tags( $alb_arn, 'TagDescriptions[].Tags[]' );

  my ($ours) = grep { $_->{Key} eq 'CreatedBy' && $_->{Value} eq 'FargateStack' } @{$tags};

  return $TRUE
    if $ours;

  # get listener rules and see if our ALB is default by finding
  # default and seeing if its target group (if any) is our target
  # group...
  my $result = $elb->describe_listeners( $alb_arn, 'Listeners[0]' );

  $result = $elb->describe_rules( $result->{ListenerArn}, 'Rules[]' );

  my ($default) = grep { $_->{IsDefault} } @{$result};

  my $default_tg_arn = $default->{Actions}->[0]->{TargetGroupArn};

  return $default_tg_arn && $default_tg_arn eq $tg_arn;
}

########################################################################
sub remove_alias_record {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $alb_arn = $config->{alb}->{arn};

  my $elb = $self->fetch_elbv2;

  my $domain = $config->{domain};

  my $query = 'LoadBalancers[0].{zone_id: CanonicalHostedZoneId, dns_name: DNSName}';

  my $alb_info = $elb->describe_load_balancers( query => $query, arn => $alb_arn );

  my $change_batch = {
    Comment => 'Delete alias record',
    Changes => [
      { Action            => 'DELETE',
        ResourceRecordSet => {
          Name        => $domain,
          Type        => 'A',
          AliasTarget => {
            HostedZoneId         => $alb_info->{zone_id},
            DNSName              => $alb_info->{dns_name},
            EvaluateTargetHealth => $JSON::false,
          }
        }
      }
    ]
  };

  my $route53 = $self->fetch_route53;

  $route53->change_resource_record_sets( $config->{route53}->{zone_id}, $change_batch );
  $route53->check_result(
    message => 'could not delete alias record for domain: [%s]',
    params  => [$domain],
    regexp  => qr/not\sfound/xsmi
  );

  return;
}

########################################################################
sub get_efs_sgs {
########################################################################
  my ( $self, $efs_id ) = @_;

  my $ec2 = $self->get_ec2;

  my $efs = $self->fetch_efs();

  my $eni_list = $efs->describe_mount_targets( $efs_id, 'MountTargets[].NetworkInterfaceId' );

  croak sprintf "ERROR: could not describe mount targets for: [%s]\n%s", $efs_id, $efs->get_error
    if !$eni_list;

  my $sgs = $ec2->describe_network_interfaces( $eni_list, 'NetworkInterfaces[].Groups[].GroupId' );

  croak sprintf "ERROR: could not describe network interfaces for: [%s]\n%s", join( q{,}, @{$eni_list} ), $ec2->get_error
    if !$sgs;

  return uniq @{$sgs};
}

########################################################################
sub authorize_efs_ingress {
########################################################################
  my ( $self, $task_sg, $efs_id ) = @_;

  my @efs_sgs = $self->get_efs_sgs($efs_id);

  my $ec2 = $self->get_ec2;

  foreach my $efs_sg (@efs_sgs) {
    $ec2->authorize_security_group_ingress(
      '--group-id'     => $efs_sg,
      '--protocol'     => 'tcp',
      '--port'         => $DEFAULT_EFS_PORT,
      '--source-group' => $task_sg,
    );
  }

  return;
}

########################################################################
sub revoke_efs_ingress {
########################################################################
  my ( $self, $task_sg, $efs_id ) = @_;

  my @efs_sgs = $self->get_efs_sgs($efs_id);

  my $ec2 = $self->get_ec2;

  foreach my $efs_sg (@efs_sgs) {
    my $result = $ec2->revoke_security_group_ingress(
      '--group-id'     => $efs_sg,
      '--protocol'     => 'tcp',
      '--port'         => $DEFAULT_EFS_PORT,
      '--source-group' => $task_sg,
    );

    next if $result || $ec2->get_error =~ /notfound/xsmi;

    croak sprintf "ERROR: could not revoke security group ingress for: [%s]\n%s", $efs_sg, $ec2->get_error;
  }

  return;
}

1;
