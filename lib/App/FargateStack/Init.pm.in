package App::FargateStack::Init;

use strict;
use warnings;

use App::FargateStack::Constants;
use App::FargateStack::Builder::Utils qw(jmespath_mapping toCamelCase log_die);

use Carp;
use Data::Dumper;
use English qw(no_match_vars);
use File::Basename qw(basename);
use List::Util qw(any none);
use Scalar::Util qw(reftype);
use YAML qw(LoadFile);

use Role::Tiny;

our $VERSION = '@PACKAGE_VERSION@';

########################################################################
sub init {
########################################################################
  my ($self) = @_;

  my $command = $self->command;

  if ( $self->get_history ) {
    $self->fetch_option_defaults;
  }

  my $cmd_spec = $self->commands->{$command};

  my $cmd_options = reftype($cmd_spec) eq 'ARRAY' ? $cmd_spec->[2] : $EMPTY;

  return
    if $cmd_options && defined $cmd_options->{init} && !$cmd_options->{init};

  my $dryrun = $self->get_dryrun;
  $self->set_dryrun( $dryrun ? '(dryrun)' : $EMPTY );

  log_die( $self, 'ERROR: when applying changes --no-update is not allowed' )
    if !$dryrun && !$self->get_update && $command eq 'apply';

  my $config = $self->_init_config;

  $self->_init_defaults($config);

  $self->_init_account;

  my $vpc_id = $config->{vpc_id};

  my $ec2 = $self->_init_ec2( $vpc_id, %{ $self->get_global_options } );

  $self->fetch_ecs->set_ec2($ec2);

  my $elb = $self->fetch_elbv2( vpc_id => $vpc_id, ec2 => $ec2 );

  # this will determine if we have an http service defined, configure
  # the ALB if it is not set explicitly and check on required parameters
  $self->_init_tasks();

  $self->_init_route53();

  $self->get_logger->trace( sub { return Dumper( [ config => $config ] ); } );

  $self->show_config;

  # only install die handler for apply - this makes sure we record any
  # provisioned resources
  if ( $self->command eq 'apply' ) {
    $SIG{__DIE__} = sub {
      my $msg = shift;

      return if $EXCEPTIONS_BEING_CAUGHT;  # eval

      # if config exists...we have removed last_updated and id
      if ( $config && $config->{config_name} ) {
        warn sprintf "Unclean shutdown - writing config file to [%s]\n", $config->{config_name};
        eval { YAML::DumpFile( $config->{config_name}, $config ); }
      }

      die $msg;
    };
  }

  return $TRUE;
}

########################################################################
sub _init_ec2 {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $subnets = $config->{subnets};

  my %options = (
    vpc_id => $config->{vpc_id},
    ( $self->get_cache && $subnets ) ? ( subnets => $subnets ) : (),
    %{ $self->get_global_options },
  );

  $self->log_debug( sub { return Dumper( [ options => \%options ] ); } );

  my $ec2 = $self->fetch_ec2(%options);

  $subnets = $ec2->get_subnets;

  $self->log_debug( sub { return Dumper( [ subnets => $subnets ] ) } );

  $self->set_subnets($subnets);

  $self->set_ec2($ec2);

  $config->{vpc_id} = $ec2->get_vpc_id;

  # if we find subnets in the config...always validate in case they
  # got changed...
  if ( $subnets && !$self->get_cache ) {
    $ec2->validate_subnets($subnets);  # this will croak if any are not invalid
  }
  else {
    my $subnets = $ec2->get_subnets;
    $self->set_subnets($subnets);
    $config->{subnets} = $subnets;
  }

  $self->log_debug( sub { return Dumper( [ subnets => $subnets ] ) } );

  return $ec2;
}

########################################################################
sub _init_config {
########################################################################
  my ($self) = @_;

  my $config_file = $self->get_config // $ENV{FARGATE_STACK_CONFIG} // 'fargate-stack.yml';

  croak sprintf "ERROR: %s not found or is unreadable\n", $config_file
    if !-s $config_file || !-r $config_file;

  $self->set_config_name($config_file);

  $self->section_break;

  $self->log_info( '%s %s (c) Copyright 2025 TBC Development Group, LLC', ref $self, $VERSION );
  $self->section_break;

  my $config = LoadFile($config_file);

  $config->{config_name} = $config_file;

  $self->set_config($config);

  return $config;
}

########################################################################
sub _init_tasks {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $tasks = $config->{tasks};

  log_die( $self, "ERROR: no tasks defined in config\n" )
    if !$tasks;

  # see if we have an http service
  my ( $http_service, $error )
    = grep { $tasks->{$_}->{type} && $tasks->{$_}->{type} =~ /^http/xsm } keys %{$tasks};

  log_die( $self, 'ERROR: only one http service is permitted' )
    if $error;

  $self->set_http($http_service);

  if ($http_service) {
    $self->configure_alb();

    log_die( $self, "ERROR: when provisioning an http task, domain is required\n" )
      if !$config->{domain};

  }

  my @images = map { $tasks->{$_}->{image} // () } keys %{$tasks};

  log_die(
    $self,
    "ERROR: every task must have an image\n%s",
    Dumper(
      [ images => \@images,
        tasks  => $tasks
      ]
    )
  ) if @images != scalar keys %{$tasks};

  return
    if $self->get_cache;

  my $ecr = $self->fetch_ecr();

  $ecr->validate_images(@images);

  return;
}

########################################################################
sub _init_account {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  if ( $config->{account} && $self->get_cache ) {
    $self->set_account( $config->{account} );
    return;
  }

  my $sts = $self->fetch_sts();

  $self->log_info('init: determining AWS account value...');

  my $result = $sts->get_caller_identity;

  log_die( $self, "ERROR: could not determine account\n%s", $sts->get_error )
    if !$result;

  $config->{account} = $result->{Account};
  $self->log_info( 'init: AWS account: [%s]...', $config->{account} );

  $self->set_account( $config->{account} );

  return;
}

########################################################################
sub _init_defaults {
########################################################################
  my ( $self, $config ) = @_;

  my $last_updated = delete $config->{last_updated};
  delete $config->{id};

  $config->{region} //= $self->get_region // $ENV{AWS_DEFAULT_REGION} // 'us-east-1';
  $self->set_region( $config->{region} );  # let's make sure we can use get_region()

  my $profile        = $self->get_profile;
  my $profile_source = 'command line';

  if ( !$profile && $config->{profile} ) {
    $profile        = $config->{profile};
    $profile_source = 'config';
  }
  elsif ( !$profile && $ENV{AWS_PROFILE} ) {
    $profile        = $ENV{AWS_PROFILE};
    $profile_source = 'environment';
  }

  if ( !$profile ) {
    $profile        = 'default';
    $profile_source = 'default';
  }

  $self->set_profile($profile);
  $config->{profile} = $profile;

  $self->set_profile_source($profile_source);

  $config->{default_log_group} //= $self->create_default('log-group');

  my %global_options = (
    profile   => $self->get_profile,
    region    => $self->get_region,
    logger    => $self->get_logger,
    log_level => $self->get_log_level,
    unlink    => $self->get_unlink,
  );

  $self->set_global_options( \%global_options );

  my $cache = $self->get_cache;
  $self->set_cache( $cache && $last_updated ? '(cached)' : $EMPTY );

  return;
}

########################################################################
sub _init_route53 {
########################################################################
  my ($self) = @_;

  my $command = $self->command;

  my @route53_commands = qw(apply plan list-zones delete-http-service);

  return
    if none { $command eq $_ } @route53_commands;

  my $config = $self->get_config;

  $self->log_trace( sub { return Dumper( [ alb => $config->{alb}, $self->get_http ] ) } );

  my ( $route53_config, $domain ) = @{$config}{qw(route53 domain)};

  if ( !$route53_config ) {
    $route53_config = {};
    $config->{route53} = $route53_config;
  }

  if ( $self->get_route53_profile ) {
    $route53_config->{profile} = $self->get_route53_profile;
  }
  else {
    $route53_config->{profile} //= $self->get_profile;
  }

  my ( $zone_id, $profile ) = @{$route53_config}{qw(zone_id profile)};

  $self->log_trace(
    sub {
      return Dumper(
        [ route53_profile => $profile,
          cli             => $self->get_route53_profile
        ]
      );
    }
  );

  my $route53 = $self->fetch_route53(
    hosted_zone_id => $zone_id,
    elb            => $self->get_elbv2,
    profile        => $profile,
  );

  return
    if !$self->get_http && $command =~ /apply|plan|list-zones/xsm;

  my $alb_type = $config->{alb}->{type};

  if ( !$zone_id ) {
    my $zone_type = $self->is_https ? 'public' : 'private';

    $self->log_warn( 'init: zone_id is required when creating a task of type: [%s]', $self->is_https ? 'https' : 'http' );

    $self->log_warn( 'init: ...attempting to find a [%s] hosted zone', $zone_type );

    my $hosted_zone = $route53->find_hosted_zone( $domain, $zone_type );
    $self->benchmark('route53');

    log_die( $self, 'init: ERROR: no hosted zone of type [%s] found in this account for domain: [%s]', $zone_type, $domain )
      if !$hosted_zone || !@{$hosted_zone};

    $zone_id = basename( $hosted_zone->[0]->{Id} );
    $route53_config->{zone_id} = $zone_id;

    return;
  }

  return
    if $self->get_cache;

  $self->log_warn( 'init: validating hosted zone id: [%s]', $zone_id );

  my $zone = eval { return $route53->validate_hosted_zone( zone_id => $zone_id, domain => $domain, alb_type => $alb_type, ); };

  my $err = $EVAL_ERROR;

  return
    if $zone && !$err;

  # output a helpful table of hosted zones for this domain
  $self->log_warn( "\n" . $self->display_hosted_zones($domain) );

  ($err) = split /\n/, $err;

  log_die( $self, $err );

  return;
}

1;
