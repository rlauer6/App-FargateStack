package App::FargateStack;

########################################################################
# Copyright (C) 2025, TBC Development Group, LLC All rights reserved.  #
# This is free software and may modified or redistributed under the    #
# same terms as Perl itself.                                           #
#                                                                      #
# Repository: https://github.com/rlauer6/App-Fargate                   #
########################################################################

use strict;
use warnings;

use App::EC2;
use App::ECS;
use App::ElbV2;
use App::Route53;

use App::FargateStack::Constants;

use Carp;
use CLI::Simple;
use CLI::Simple::Constants qw(:booleans :chars %LOG_LEVELS);
use Data::Dumper;
use Date::Parse qw(str2time);
use English qw(no_match_vars);
use File::Basename qw(basename);
use List::Util qw(none);
use Log::Log4perl;
use Pod::Usage;
use Scalar::Util qw(reftype);
use Text::ASCIITable::EasyTable;
use YAML qw(LoadFile);

use Role::Tiny::With;

with 'App::Benchmark';
with 'App::FargateStack::Builder';
with 'App::FargateStack::Builder::IAM';
with 'App::FargateStack::Builder::Certificate';
with 'App::FargateStack::Builder::Events';
with 'App::FargateStack::Builder::EFS';
with 'App::FargateStack::Builder::HTTPService';
with 'App::FargateStack::Builder::Cluster';
with 'App::FargateStack::Builder::LogGroup';
with 'App::FargateStack::Builder::SecurityGroup';
with 'App::FargateStack::Builder::Secrets';
with 'App::FargateStack::Builder::Service';
with 'App::FargateStack::Builder::S3Bucket';
with 'App::FargateStack::Builder::SQSQueue';
with 'App::FargateStack::Builder::TaskDefinition';
with 'App::FargateStack::Builder::Utils';

our $VERSION = '@PACKAGE_VERSION@';

use parent qw(CLI::Simple);

caller or __PACKAGE__->main;

########################################################################
sub init {
########################################################################
  my ($self) = @_;

  my $command = $self->command;

  return
    if $command =~ /version|help/xsm;

  if ( !$self->get_log_level ) {
    my $log_level = $command =~ /logs|status|-service/xsm ? 'error' : 'info';
    $self->get_logger->level( $LOG_LEVELS{$log_level} );
  }

  my $dryrun = $self->get_dryrun;
  $self->set_dryrun( $dryrun ? '(dryrun)' : $EMPTY );

  log_die( $self, 'ERROR: when applying changes --no-update is not allowed' )
    if !$dryrun && !$self->get_update;

  my $config = $self->_init_config;

  $self->_init_defaults($config);

  $self->_init_account;

  my $ec2 = $self->_init_ec2( $config->{vpc_id}, %{ $self->get_global_options } );

  $self->set_ecs(
    App::ECS->new(
      ec2 => $ec2,
      %{ $self->get_global_options },
    )
  );

  my $elb = App::ElbV2->new(
    vpc_id => $config->{vpc_id},
    ec2    => $ec2,
    %{ $self->get_global_options },
  );

  $self->set_elb($elb);

  # this will determine if we have an http service defined, configure
  # the ALB if it is not set explicitly and check on required parameters
  $self->_init_tasks();

  $self->_init_route53();

  $self->get_logger->trace( sub { return Dumper( [ config => $config ] ); } );

  $self->show_config;

  # only install die handler for apply - this makes sure we record any
  # provisioned resources
  if ( $self->command eq 'apply' ) {
    $SIG{__DIE__} = sub {
      my $msg = shift;

      return if $^S;  # eval

      # if config exists...we have removed last_updated and id
      if ( $config && $config->{config_name} ) {
        warn sprintf "Unclean shutdown - writing config file to [%s]\n", $config->{config_name};
        eval { YAML::DumpFile( $config->{config_name}, $config ); };
      }

      die $msg;
    };
  }

  return $TRUE;
}

########################################################################
sub show_config {
########################################################################
  my ($self) = @_;

  my $config  = $self->get_config;
  my $subnets = $self->get_subnets;

  $self->log_info( 'init:           account: [%s]', $self->get_account );
  $self->log_info( 'init:           profile: [%s]', $self->get_profile );
  $self->log_info( 'init:    profile source: [%s]', $self->get_profile_source );
  $self->log_info( 'init:            region: [%s]', $self->get_region );
  $self->section_break;

  $self->log_info( 'init:   route53 profile: [%s]', $config->{route53}->{profile} // q{-} );
  $self->log_info( 'init:   route53 zone_id: [%s]', $config->{route53}->{zone_id} // q{-} );
  $self->section_break;

  $self->log_info( 'init:          app name: [%s]', $config->{app}->{name} );
  $self->log_info( 'init:       app version: [%s]', $config->{app}->{version} // q{-} );
  $self->log_info( 'init:     https service: [%s]', $self->get_http           // q{-} );
  $self->log_info( 'init:  scheduled events: [%s]', $self->has_events ? 'yes' : 'no' );
  $self->section_break;

  $self->log_info( 'init:    subnets in VPC: [%s]', $config->{vpc_id} );
  $self->log_info( '                 public: [%s]', join q{,}, @{ $subnets->{private} || [] } );
  $self->log_info( '                private: [%s]', join q{,}, @{ $subnets->{public}  || [] } );
  $self->section_break;

  $self->log_info( 'init:            config: [%s]', $self->get_config_name );
  $self->log_info( 'init:         log level: [%s]', $self->get_log_level // 'info' );
  $self->log_info( 'init:             cache: [%s]', $self->get_cache ? 'enabled' : 'disabled' );
  $self->log_warn( 'init:     update config: [%s]', $self->get_update ? 'yes' : 'no' );
  $self->log_warn( 'init:            dryrun: [%s]', $self->get_dryrun ? 'yes' : 'no' );

  return;
}

########################################################################
sub _init_tasks {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $tasks = $config->{tasks};

  log_die( $self, "ERROR: no tasks defined in config\n" )
    if !$tasks;

  # see if we have an http service
  my ( $http_service, $error )
    = grep { $tasks->{$_}->{type} && $tasks->{$_}->{type} =~ /^http/xsm } keys %{$tasks};

  log_die( $self, 'ERROR: only one http service is permitted' )
    if $error;

  $self->set_http($http_service);

  if ($http_service) {
    $self->configure_alb();

    log_die( $self, "ERROR: when provisioning an http task, domain is required\n" )
      if !$config->{domain};

  }

  my @images = map { $tasks->{$_}->{image} // () } keys %{$tasks};

  log_die( $self, "ERROR: every task must have an image\n" . Dumper( [ images => \@images, tasks => $tasks ] ) )
    if @images != scalar keys %{$tasks};

  return
    if $self->get_cache;

  require App::ECR;

  my $ecr = App::ECR->new( $self->get_global_options );

  $ecr->validate_images(@images);

  return;
}

########################################################################
sub _init_account {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  if ( $config->{account} && $self->get_cache ) {
    $self->set_account( $config->{account} );
    return;
  }

  require App::STS;

  my $sts = App::STS->new( profile => $self->get_profile, %{ $self->get_global_options } );

  $self->set_sts($sts);

  $self->log_info('init: determining AWS account value...');

  my $result = $sts->get_caller_identity;

  log_die( $self, "ERROR: could not determine account\n%s", $sts->get_error )
    if !$result;

  $config->{account} = $result->{Account};
  $self->log_info( 'init: AWS account: [%s]...', $config->{account} );

  $self->set_account( $config->{account} );

  return;
}

########################################################################
sub _init_defaults {
########################################################################
  my ( $self, $config ) = @_;

  my $last_updated = delete $config->{last_updated};
  delete $config->{id};

  $config->{region} //= $self->get_region // $ENV{AWS_DEFAULT_REGION} // 'us-east-1';
  $self->set_region( $config->{region} );  # let's make sure we can use get_region()

  my $profile        = $self->get_profile;
  my $profile_source = 'command line';

  if ( !$profile && $config->{profile} ) {
    $profile        = $config->{profile};
    $profile_source = 'config';
  }
  elsif ( !$profile && $ENV{AWS_PROFILE} ) {
    $profile        = $ENV{AWS_PROFILE};
    $profile_source = 'environment';
  }

  if ( !$profile ) {
    $profile        = 'default';
    $profile_source = 'default';
  }

  $self->set_profile($profile);
  $config->{profile} = $profile;

  $self->set_profile_source($profile_source);

  $config->{default_log_group} //= sprintf '/ecs/' . $config->{app}->{name};

  my %global_options = (
    profile   => $self->get_profile,
    region    => $self->get_region,
    logger    => $self->get_logger,
    log_level => $self->get_log_level,
    unlink    => $self->get_unlink,
  );

  $self->set_global_options( \%global_options );

  my $cache = $self->get_cache;
  $self->set_cache( $cache && $last_updated ? '(cached)' : $EMPTY );

  return;
}

########################################################################
sub _init_route53 {
########################################################################
  my ($self) = @_;

  my $command = $self->command;

  my @route53_commands = qw(apply plan list-hosted-zones);

  return
    if none { $command eq $_ } @route53_commands;

  return
    if !$self->get_http && $command =~ /apply|plan/xsm;

  my $config = $self->get_config;

  $self->log_trace( sub { return Dumper( [ alb => $config->{alb}, $self->get_http ] ) } );

  my $alb_type = $config->{alb}->{type};

  my ( $route53_config, $domain ) = @{$config}{qw(route53 domain)};

  if ( !$route53_config ) {
    $route53_config = {};
    $config->{route53} = $route53_config;
  }

  $route53_config->{profile} //= $self->get_profile;

  my ( $zone_id, $profile ) = @{$route53_config}{qw(zone_id profile)};

  my $route53 = App::Route53->new(
    hosted_zone_id => $zone_id,
    elb            => $self->get_elb,
    %{ $self->get_global_options },
    profile => $profile,
  );

  $self->set_route53($route53);

  if ( !$zone_id ) {
    my $zone_type = $self->is_https ? 'public' : 'private';

    $self->log_warn( 'init: zone_id is required when creating a task of type: [%s]',
      $self->is_https ? 'https' : 'http' );

    $self->log_warn( 'init: ...attempting to find a [%s] hosted zone', $zone_type );

    my $hosted_zone = $route53->find_hosted_zone( $domain, $zone_type );
    $self->benchmark('route53');

    log_die( $self, 'init: ERROR: no hosted zone of type [%s] found in this account for domain: [%s]',
      $zone_type, $domain )
      if !$hosted_zone || !@{$hosted_zone};

    $zone_id = basename( $hosted_zone->[0]->{Id} );
    $route53_config->{zone_id} = $zone_id;

    return;
  }

  return
    if $self->get_cache;

  $self->log_warn( 'init: validating hosted zone id: [%s]', $zone_id );

  my $zone = eval {
    return $route53->validate_hosted_zone(
      zone_id  => $zone_id,
      domain   => $domain,
      alb_type => $alb_type,
    );
  };

  my $err = $EVAL_ERROR;

  return
    if $zone && !$err;

  # output a helpful table of hosted zones for this domain
  $self->log_warn( "\n" . $self->display_hosted_zones($domain) );

  ($err) = split /\n/, $err;

  log_die( $self, $err );

  return;
}

########################################################################
sub cmd_logs {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my ( $task_name, $start, $end ) = $self->get_args;

  $self->check_task($task_name);

  my $tasks = $config->{tasks};

  my $task = $tasks->{$task_name};

  my ( $start_time, $end_time ) = normalize_time_range( $start, $end );

  require App::Logs;

  my $logs = App::Logs->new( $self->get_global_options );

  my $query = 'logStreams[0]|{name: logStreamName, timestamp: firstEventTimestamp}';

  my $log_group = $task->{log_group}->{name};

  my $stream = $logs->command(
    'describe-log-streams' => [
      '--log-group-name' => $log_group,
      '--order-by'       => 'LastEventTime',
      '--descending',
      '--query' => $query,
    ]
  );

  croak "ERROR: could not describe log group [%s]\n%s\n", $log_group, $logs->get_error
    if !$stream;

  my %options = (
    '--log-group-name'  => $log_group,
    '--log-stream-name' => $stream->{name},
  );

  $start_time //= $stream->{timestamp};

  my $events = $logs->command(
    'get-log-events' => [
      %options,
      $start_time ? ( '--start-time' => $start_time ) : (),
      $end_time   ? ( '--end-time'   => $end_time )   : (),
    ]
  );

  EVENT:
  while ( $events && @{ $events->{events} } ) {
    my @log_events = @{ $events->{events} };

    foreach my $e (@log_events) {
      my ( $timestamp, $message ) = @{$e}{qw(timestamp message)};
      $timestamp = $self->get_log_time ? scalar localtime $timestamp / 1000 : $EMPTY;

      print {*STDOUT} sprintf "%s - %s\n", $timestamp, $message;
    }

    my $token = $events->{nextForwardToken};

    while ($TRUE) {
      $events = $logs->command( 'get-log-events', [ %options, '--next-token' => $token ] );

      if ( !$events || !@{ $events->{events} } ) {
        last EVENT
          if !$self->get_log_wait;

        sleep $DEFAULT_LOG_POLL_TIME;
      }
      else {
        last;
      }
    }
  }

  return $SUCCESS;
}

########################################################################
sub normalize_time_range {
########################################################################
  my ( $start, $end ) = @_;

  return
    if !$start;

  my $now = time;

  my $start_epoch = _to_epoch( $start, $now );
  my $end_epoch   = defined $end ? _to_epoch( $end, $now ) : undef;

  croak 'start is in the future' if $start_epoch > $now;
  croak 'end is in the future'   if defined $end_epoch && $end_epoch > $now;
  croak 'start > end'            if defined $end_epoch && $start_epoch > $end_epoch;

  return ( $start_epoch * 1000, defined $end_epoch ? $end_epoch * 1000 : undef );
}

########################################################################
sub _to_epoch {
########################################################################
  my ( $value, $now ) = @_;

  # Duration syntax (e.g. 5d, 30m, 2h)
  if ( $value =~ /^(\d+)([dmh])$/xsmi ) {
    my ( $n, $unit ) = ( $1, lc $2 );
    croak 'duration cannot be zero' if $n == 0;

    my %span = (
      d => $SEC_PER_DAY,
      h => $SEC_PER_HOUR,
      m => $SEC_PER_MIN,
    );

    return $now - $n * $span{$unit};
  }

  # Date string ‑ let Date::Parse do the heavy lifting
  my $epoch = str2time($value);

  croak "unrecognized date format: [$value]"
    if !defined $epoch;

  return $epoch;
}

########################################################################
sub cmd_list_zones {
########################################################################
  my ($self) = @_;

  my ($domain) = $self->get_args;

  croak sprintf "usage: %s list-zones domain\n", $ENV{SCRIPT_NAME}
    if !$domain;

  print {*STDOUT} $self->display_hosted_zones($domain);

  return $SUCCESS;
}

########################################################################
sub display_hosted_zones {
########################################################################
  my ( $self, $domain ) = @_;

  if ( !$self->get_route53 ) {
    $self->set_route53( App::Route53->new( $self->get_global_options ) );
  }

  my $hosted_zones = $self->get_route53->list_hosted_zones;

  return
    if !$hosted_zones || !@{ $hosted_zones->{HostedZones} };

  my @zones = @{ $hosted_zones->{HostedZones} };

  my @data;

  foreach my $zone (@zones) {
    my $name = $zone->{Name};
    $name =~ s/[.]$//xsm;

    next if $domain !~ /$name/xsm;

    my ($zone_id) = ( split /\//xsm, $zone->{Id} )[-1];

    push @data, { 'Zone Id' => $zone_id, Name => $zone->{Name} };
  }

  my $title = sprintf 'Hosted Zones (%s)', $domain;

  my $table = easy_table(
    data          => [@data],
    table_options => { headingText => $title },
    columns       => [ 'Zone Id', 'Name' ],
  );

  return $table;
}

########################################################################
sub _init_ec2 {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $subnets = $config->{subnets};

  my $ec2 = App::EC2->new(
    vpc_id => $config->{vpc_id},
    ( $self->get_cache && $subnets ) ? ( subnets => $subnets ) : (),
    %{ $self->get_global_options },
  );

  $subnets = $ec2->get_subnets;

  $self->get_logger->trace( sub { return Dumper( [ subnets => $subnets ] ) } );

  $self->set_subnets($subnets);

  $self->set_ec2($ec2);

  $config->{vpc_id} = $ec2->get_vpc_id;

  # if we find subnets in the config...always validate in case they
  # got changed...
  if ( $subnets && !$self->get_cache ) {
    $ec2->validate_subnets($subnets);  # this will croak if any are invalid
  }
  else {
    my $subnets = $ec2->get_subnets;
    $self->set_subnets($subnets);
    $config->{subnets} = $subnets;
  }

  $self->get_logger->trace( sub { return Dumper( [ subnets => $subnets ] ) } );

  return $ec2;
}

########################################################################
sub cmd_service_status {
########################################################################
  my ($self) = @_;

  my ($service_name) = $self->get_args;

  my $query
    = 'services[0]|{running: runningCount, desired: desiredCount,status: status, pending: pendingCount,  events: events}';

  my $result = $self->get_ecs->describe_services(
    cluster_name => $self->get_config->{cluster}->{name},
    service_name => $service_name,
    query        => $query,
  );

  log_die( $self, "ERROR: could not describe service [%s]\n%s", $service_name, $self->get_ecs->get_error )
    if !$result;

  my $title = sprintf 'Service: %s Status:[%s] Running: [%s] Pending: [%s] Desired: [%s]', $service_name,
    @{$result}{qw(status running pending desired)};

  my @data = map { { 'Time' => $_->{createdAt}, Event => $_->{message} } } @{ $result->{events} };

  print {*STDOUT} easy_table(
    table_options => { headingText => $title },
    data          => \@data,
    columns       => [qw(Time Event)],
  );

  return $SUCCESS;
}

########################################################################
sub _init_config {
########################################################################
  my ($self) = @_;

  my $config_file = $self->get_config;

  croak sprintf "usage: %s --config config-file command\n", $ENV{SCRIPT_NAME}
    if !$config_file;

  croak sprintf "ERROR: %s not found or is unreadable\n"
    if !-s $config_file || !-r $config_file;

  $self->set_config_name($config_file);

  $self->section_break;

  $self->log_info( '%s %s (c) Copyright 2025 TBC Development Group, LLC', ref $self, $VERSION );
  $self->section_break;

  my $config = LoadFile($config_file);

  $config->{config_name} = $config_file;

  $self->set_config($config);

  return $config;
}

########################################################################
sub cmd_run_task {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my ($task_name) = $self->get_args;

  log_die( $self, "usage: %s run-task task-name\n", $ENV{SCRIPT_NAME} )
    if !$task_name;

  my $task = $config->{tasks}->{$task_name};

  log_die( $self, "ERROR: no such task [%s] defined in config\n", $task_name )
    if !$task;

  my @subnets = @{ $self->get_subnets->{private} // [] };

  if ( !@subnets ) {
    $self->log_warn('run-task: using public subnets is not recommended...');
    @subnets = @{ $self->get_subnets->{public} // [] };
  }

  my $network_configuration = {
    awsvpcConfiguration => {
      subnets        => [ @subnets[ 0, 1 ] ],
      securityGroups => [ $config->{security_groups}->{fargate}->{group_id} ],
      assignPublicIp => 'DISABLED',
    }
  };

  my $cluster_name = $config->{cluster}->{name};

  $self->log_warn( 'run-task: launching [%s] in cluster [%s]', $task_name, $cluster_name );

  my $result = $self->get_ecs->run_task(
    cluster               => $cluster_name,
    task_definition       => $task_name,
    network_configuration => $network_configuration,
  );

  log_die( $self, "ERROR: could not run task [%s]\n%s\n", $task_name, $self->get_ecs->get_error )
    if !$result;

  my @failures = @{ $result->{failures} };

  log_die( $self, 'ERROR: task failed to launch: %s', Dumper( \@failures ) )
    if @failures;

  my ($tasks) = @{ $result->{tasks} };

  my $task_arn = $tasks->{taskArn};

  my $should_wait = $self->get_wait ? '(waiting)' : $EMPTY;

  $self->log_warn( 'run-task: task [%s] launched. ARN: [%s]...%s', $task_name, $task_arn, $should_wait );

  my $poll_limit = $self->get_task_timeout / $DEFAULT_ECS_POLL_TIME;

  if ($should_wait) {
    my $poll_count = 0;

    while ( $poll_count++ < $poll_limit ) {
      my $query = 'tasks[0].{Status:lastStatus, Exit:containers[0].exitCode, Reason:stoppedReason}';

      my $result = $self->get_ecs->describe_tasks( $cluster_name, $task_arn, $query );

      $self->log_warn( 'run-task: task [%s] status: [%s], exit code:[%s], reason: [%s]',
        $task_name, map { $_ // q{-} } @{$result}{qw(Status Exit Reason)} );

      last if $result->{Status} eq 'STOPPED';

      sleep $DEFAULT_ECS_POLL_TIME;
    }

    my $log_group = $config->{tasks}->{$task_name}->{log_group}->{name};

    # by convention our log groups are named after our app
    my $log_stream = sprintf '%s/%s/%s', $config->{app}->{name}, $task_name, ( split /\//xsm, $task_arn )[-1];

    require App::Logs;

    my $logs = App::Logs->new(
      %{ $self->get_global_options },
      log_group_name  => $log_group,
      log_stream_name => $log_stream
    );

    my $events = $logs->get_log_events();

    log_die( $self, "run-task: unable to get logs from log group: [%s], stream: [%s]\n%s",
      $log_group, $log_stream, $logs->get_error )
      if !$events;

    while ( $events && @{ $events->{events} } ) {

      foreach my $e ( @{ $events->{events} } ) {

        my ( $timestamp, $message ) = @{$e}{qw(timestamp message)};
        $timestamp = scalar localtime $timestamp / 1000;

        print {*STDOUT} sprintf "%s - %s\n", $timestamp, $message;
      }

      $events = $logs->get_next_log_events( $events->{nextForwardToken} );
    }
  }

  return $SUCCESS;
}

########################################################################
sub cmd_create_service {
########################################################################
  my ($self) = @_;

  my ($task_name) = $self->get_args;

  my $config = $self->get_config;

  log_die( $self, "usage: $ENV{SCRIPT_NAME} create-service task-name\n" )
    if !$task_name;

  log_die( $self, "no such task defined in config [%s]\n", $task_name )
    if !$config->{tasks}->{$task_name};

  return $self->build_service($task_name);
}

########################################################################
sub check_task {
########################################################################
  my ( $self, $task_name, $warn ) = @_;

  my $level = $warn ? 'warn' : 'die';

  my $config = $self->get_config;

  return $TRUE
    if $task_name && $config->{tasks}->{$task_name};

  log_die( $self, 'ERROR:  no such task [%s] defined in config', $task_name )
    if $level eq 'die';

  $self->get_logger->warn( 'WARNING: no such task [%s] defined in config...trying anyway  ¯\_(ツ)_/¯',
    $task_name );

  return;
}

########################################################################
sub cmd_delete_service {
########################################################################
  my ($self) = @_;

  my ($task_name) = $self->get_args;

  croak "usage: %s delete-service task-name\n", $ENV{SCRIPT_NAME}
    if !$task_name;

  my $config = $self->get_config;

  $self->check_task( $task_name, 'warn' );

  my $ecs = $self->get_ecs;

  my $result = $ecs->delete_service( $config->{cluster}->{name}, $task_name );

  log_die( $self, "ERROR: could not stop service %s\n%s", $task_name, $ecs->get_error )
    if $ecs->get_error;

  return $SUCCESS;
}

########################################################################
sub _update_task_count {
########################################################################
  my ( $self, $task_name, $desired_count ) = @_;

  my $config = $self->get_config;

  my $ecs = $self->get_ecs;

  my $cluster_name = $config->{cluster}->{name};

  my $result = $ecs->command(
    'update-service' => [
      '--cluster'       => $cluster_name,
      '--service'       => $task_name,
      '--desired-count' => $desired_count,
    ]
  );

  log_die( $self, "ERROR: could not update service: [%s]\n%s", $task_name, $ecs->get_error )
    if !$result;

  return $result;
}

########################################################################
sub cmd_update_service {
########################################################################
  my ($self) = @_;

  my ( $task_name, $count ) = $self->get_args;

  if ( $self->command eq 'start-service' ) {
    $count ||= 1;
  }
  else {
    $count = 0;
  }

  $self->check_task( $task_name, 'warn' );

  if ( !$task_name ) {
    if ( $count == 0 ) {
      croak sprintf "usage: %s -c config-name stop-service task-name\n", $ENV{SCRIPT_NAME};
    }

    croak sprintf "usage: %s -c config-name start-service task-name [count]\n", $ENV{SCRIPT_NAME};
  }

  my $result = $self->_update_task_count( $task_name, $count );

  return $self->cmd_service_status;
}

########################################################################
sub cmd_register {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my ($task_name) = $self->get_args;

  my $dryrun = $self->get_dryrun;

  my $action = $self->get_skip_register ? 'update-target' : 'register';

  log_die( $self, 'usage: %s %s task-name', $action, $ENV{SCRIPT_NAME} )
    if !$task_name;

  my $ecs = $self->get_ecs;

  my $task_definition_file = sprintf 'taskdef-%s.json', $task_name;

  log_die( $self, "ERROR: no such task [%s] defined in config\n", $task_name )
    if !$config->{tasks}->{$task_name};

  log_die( $self, "ERROR: no task definition file found for %s\n", $task_name )
    if !-s $task_definition_file;

  my $task_definition_arn = $config->{tasks}->{$task_name}->{arn};

  if ( !$self->get_skip_register ) {
    $self->log_warn( 'register: registering [%s]...%s', $task_name, $dryrun );

    if ( !$dryrun ) {
      my $task_definition = $ecs->register_task_definition($task_definition_file);

      $task_definition_arn = $task_definition_arn->{taskDefinition}->{taskDefinitionArn};
      $self->log_warn( 'register: registered...[%s]', $task_definition_arn );
    }
  }

  ## - events -
  if ( $config->{tasks}->{$task_name}->{type} eq 'task' ) {
    my $event = App::Events->new( $self->get_global_options );

    my $rule_name = sprintf '%s-schedule', $task_name;

    my $target = $event->list_targets_by_rule( $rule_name, 'Targets' );

    if ( $target && @{$target} ) {

      if ( !$dryrun ) {
        $config->{tasks}->{$task_name}->{arn} = $task_definition_arn;
        $self->update_config;  # record new task definition arn
      }

      $self->create_event_target($task_name);
    }
  }

  return $SUCCESS;
}

########################################################################
sub cmd_explain {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  return $SUCCESS;
}

########################################################################
sub cmd_version {
########################################################################

  my $version_stmt = <<'END_OF_TEXT';
%s %s
Copyright 2025 (c) TBC Development Group, LLC.

License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
END_OF_TEXT

  my $pgm = $ENV{SCRIPT_NAME} // $PROGRAM_NAME;

  print {*STDOUT} sprintf $version_stmt, $pgm, $VERSION;

  return $SUCCESS;
}

########################################################################
sub help {
########################################################################
  my ($self) = @_;

  my $subject = lc join $SPACE, @ARGV;
  $subject =~ s/\s+$//xsm;

  my $section = $HELP_SUBJECTS{$subject} // $EMPTY;

  if ( !$section ) {
    my @possible_subjects = grep {/$subject/xsmi} keys %HELP_SUBJECTS;

    if ( @possible_subjects == 1 ) {
      $section = $HELP_SUBJECTS{ $possible_subjects[0] };
    }
    elsif (@possible_subjects) {
      print {*STDERR} sprintf "'%s' was not found in the help index.\n\nPossible matches:\n\t* %s\n", $subject,
        join "\n\t* ",
        @possible_subjects;
      exit 1;
    }
  }

  if ( $section && ref $section ) {
    $section = $section->[0];
  }
  else {  # a help subject alias
    my $reference = $HELP_SUBJECTS{$section};
    $section = $reference->[0];
  }

  if ( !$section ) {
    if ( $subject ne 'list' ) {
      print {*STDERR} sprintf "'%s' is not a valid subject\n", $subject;
    }

    my @data;

    foreach my $keyword ( sort keys %HELP_SUBJECTS ) {
      my $description = $HELP_SUBJECTS{$keyword};
      if ( ref $description ) {
        $description = $description->[1];
      }
      push @data, { Keyword => $keyword, Description => $description };
    }

    my $table = easy_table(
      columns       => [qw(Keyword Description)],
      data          => \@data,
      table_options => { headingText => 'Help Subjects' },
    );

    print {*STDOUT} $table;

    return $SUCCESS;
  }

  eval {
    require IO::Pager;
    IO::Pager::open( *STDOUT, '|-:utf8', 'Unbuffered' );
  };

  return pod2usage(
    -exitval => 1,
    ( -verbose => $section ? 99 : 1 ),
    $section ? ( -sections => uc $section ) : ()
  );
}

########################################################################
sub init_logger {
########################################################################
  my ($self) = @_;

  my $log4perl_conf = $LOG4PERL_CONF;

  if ( !$self->get_color ) {
    $log4perl_conf =~ s/\ColoredLevels//xsm;
  }

  Log::Log4perl->init( \$log4perl_conf );

  $self->set_logger( Log::Log4perl->get_logger );

  my $level = $self->get_log_level;

  $self->get_logger->level( $LOG_LEVELS{ $level // 'info' } );

  return;
}

########################################################################
sub cmd_plan {
########################################################################
  my ( $self, @args ) = @_;

  $self->set_dryrun('(dryrun)');

  return $self->build(@args);
}

########################################################################
sub cmd_apply {
########################################################################
  my ( $self, @args ) = @_;

  $self->set_dryrun($EMPTY);

  return $self->build(@args);
}

########################################################################
sub cmd_update_target {
########################################################################
  my ( $self, @args ) = @_;

  $self->set_skip_register($TRUE);

  return $self->cmd_register(@args);
}

########################################################################
sub main {
########################################################################

  my @extra_options = qw(
    account
    alb
    config_name
    ec2
    ecs
    efs
    elb
    events
    existing_resources
    http
    iam
    global_options
    logs
    log_groups
    logger
    profile_source
    required_resources
    route53
    sts
    secrets
    subnets
    taskdef_status
  );

  my @option_specs = qw(
    help
    config|c=s
    color!
    create-alb|C
    dryrun
    force|f
    profile=s
    log-level=s
    log-time!
    log-wait!
    region=s
    skip-register
    task-timeout
    update|u!
    unlink|U!
    cache!
    version|v
    wait|w!
  );

  my %default_options = (
    'update'       => $TRUE,
    wait           => $TRUE,
    unlink         => $TRUE,
    color          => $TRUE,
    cache          => $TRUE,
    'log-time'     => $TRUE,
    'log-wait'     => $TRUE,
    'task-timeout' => $DEFAULT_ECS_POLL_LIMIT,
  );

  my %commands = (
    'create-service' => \&cmd_create_service,
    'delete-service' => \&cmd_delete_service,
    'run-task'       => \&cmd_run_task,
    'start-service'  => \&cmd_update_service,
    'stop-service'   => \&cmd_update_service,
    status           => \&cmd_service_status,
    'update-target'  => \&cmd_update_target,
    apply            => \&cmd_apply,
    default          => \&cmd_explain,
    help             => \&help,
    'list-zones'     => \&cmd_list_zones,
    logs             => \&cmd_logs,
    plan             => \&cmd_plan,
    register         => \&cmd_register,
    start            => \&cmd_start_service,
    stop             => \&cmd_stop_service,
    version          => \&cmd_version,
  );

  my $fargate_stack = App::FargateStack->new(
    commands        => \%commands,
    default_options => \%default_options,
    extra_options   => \@extra_options,
    option_specs    => \@option_specs,
  );

  $fargate_stack->run();

  return 0;
}

1;

__END__

=pod

=head1 NAME

App::FargateStack

=head1 SYNOPSIS

 app-FargateStack Options Command

=head2 Commands

 help {subject}             displays general help or help on a particular subject (see Note 2)
 apply                      reads config and creates resources
 create-service task-name   create a new service (see Note 4)
 delete-service task-name   delete an existing service
 list-zones domain          list the hosted zones for a domain
 logs task-name start end   display CloudWatch logs (see Note 5)
 plan                       reads config and reports on resource creation
 register task-name        
 run-task task-name
 update-target task-name
 version                     show version number

=head2 Options

 -h, --help                 help
 -c, --config               path to the .yml configuration
 -C, --create-alb           forces creation of a new ALB instead of using an existing ALB
 -d, --dryrun               just report actions, do not apply
 --color, --no-color        default: color
 --log-level                'trace', 'debug', 'info', 'warn', 'error', default: info (See Note 6)
 --log-time, --no-log-time  for logs command, output CloudWatch timestamp (default: --no-log-time)
 --log-wait, --no-log-wait  for logs command, continue to monitor logs (default: --log-wait)
 -p, --profile              AWS profile (see Note 1)
 -u, --update, --no-update  update config
 -w, --wait, --no-wait      wait for tasks to complete and then dump the log
 -v, --version              script version

=head2 Notes

=over 4

=item 1. Use the --profile option to override the profile defined in
the configuration file.

The Route 53 service uses the same profile unless you specify a profile
name in the C<route53> section of the configuraiton file.

=item 2. You can get help using the C<--help> option or use the help
command with a subject.

 app-FargateStack help overview

If you do not provide a subject then you will get the same information
as C<--help>. Use C<help list> to get a list of available subjects.

=item 3. You must log at least at the 'info' level to report progress.

=item 4. By default an ECS service is NOT created for you by default
for daemon and http tasks.

=item 5. You can tail logs or just dump logs for a task's log stream

 app-Fargate [--log-wait] [--log-time] logs task-name start end

=over 8

=item --log-wait --no-log-wait (optional)

Continue to monitor stream and dump logs to STDOUT

default: --log-wait

=item --log-time, --no-log-time (optional)

Output the CloudWatch timestamp of the message.

default: --no-log-time

=item task-name

The name of the task whose logs you want to view.

=item start

Starting date and time of the log events to display. Format can be one
of:

 Nd => N days ago
 Nm => N minutes ago
 Nh => N hours ago

 mm/dd/yyyy
 mm/dd/yyyy hh:mm::ss

=item end

If provided both start and end must date-time strings.

=back

=item 6. The default logging level is 'info'. Logging at lower levels will prevent potential useful messages from being displayed. To see the AWS CLI commands being executed, log at the 'debug' level. The 'trace' level will output data objects and is mainly used for debugging.

=back

=head1 COMMANDS

=head2  help {subject}             

=head2  apply                      

=head2  create-service task-name   

=head2  delete-service task-name   

=head2  list-zones domain          

=head2  logs task-name start end   

=head2  plan                       

=head2  register task-name        

=head2  run-task task-name

=head2  update-target task-name

=head2  version                    

=head1 OVERVIEW

I<NOTE: This is a brief overview of C<App::FargateStack>. To see a 
list of topics providing more detail use the C<help list> command.>

The C<App::Fargate> framework, as its name implies provide developers
with a tool to create Fargate tasks and services. It has been designed
to make creating and launching Fargate based services as simple as
possible. Accordingly, it provides logical and pragmatic defaults
based on the common uses for Fargate based applications. You can
however customize many of the resources being built by the
script.

Using a YAML based configuration file, you specify the your required
resources and their attributes, run the C<app-FargateStack> script and
launch your application.

Using this framework you can:

=over 4

=item * ...build internal or external facing HTTP services that:

=over 8

=item * ...automatically provision certificates for external facing web applications

=item * ...use an existing or create a new internal or external facing application load balancer (ALB).

=item * ...automatically create an alias record in Route 53 for your domain

=item * ...create a redirect listener rule to redirect port 80 requests to 443 

=back

=item * ...create queues and buckets to support your application

=item * ...use a dryrun mode to report the resources that will built
before building them

=item * ...run C<app-FargateStack> multiple times (idempotency)

=item * ...create daemon services

=item * ...create scheduled jobs

=item * ...execute adhoc jobs

=back

=head2 Additional Features

=over 4

=item - inject secrets into the container's environment using a simple syntax (See L</SECRETS MANAGEMENT>)

=item - detection and re-use of existing resources like EFS files systems, load balancers, buckets and queues

=item - automatic IAM role and policy generation based on configured resources

=item - define an launch multiple independent Fargate tasks and services under a single stack

=item - automatic creation of log groups with customizable retention period

=item - discovery of existing environment to intelligently populate configuration defaults

back

=head2 Minimal Configuration

Getting a Fargate task up and running requires that you provision and
configure multiple AWS resources. Stitching it together using
B<Terraform> or B<CloudFormation> can be tedious and time consuming,
even if you know what resources to provision AND how to stitch it
together.

The motivation behind writing this framework was to take the drudgery
of writing declarative resource generators for all of the resources required
to run a simple task, create basic web applications or RESTful
APIs. Instead, we wanted a framework that covered 90% of our use cases
while allowing our development workflow to go something like:

=over 4

=item 1. Create a Docker image that implements our worker, web app or API

=item 2. Create a minimal configuration file that describes our application

=item 3. Execute the framework's script and create the necessary AWS infrastructure

=item 4. Launch the http server, daemon, scheduled job, or adhoc worker

=back

Of course, this is only a "good idea" if #2 is truly minimal,
otherwise it becomes an exercise similar to using Terraform or
CloudFormation. So what is the minimum amount of configuration to
inform our framework for creating our Fargate worker? How 'bout this:

 ---
 app:
   name: my-stack
 tasks:
   my-worker:
     type: task
     image: my-worker:latest
     schedule: cron(50 12 * * * *)

Using this minimal configuration and running C<app-FargateStack>t like this:

 app-FargateStack -c --profile prod minimal.yml plan

...would create the following resources in your default VPC:

=over 8

=item * a cluster name C<my-stack-cluster>

=item * a security group for the cluster

=item * an IAM role for the the cluster

=item * an IAM  policy that has permissions enabling your worker

=item * an ECS task definition for your work with defaults

=item * a CloudWatch log group

=item * an EventBridge target event

=item * an IAM role for EventBridge

=item * an IAM policy for EventBridge

=item * an EventBridge rule that schedules the worker

=back

...so as you can see this can be a daunting task which becomes even
more annoying when you want your worker to be able to access other AWS
resources like buckets, queues or EFS directories.

=head2 Web Applications

Creating a web application using a minimal configuration works too. To
build a web application you can start with this minimal configuration:

 ---
 app:
   name: my-web-app
 domain: my-web-app.example.com
 route53:
   zone_id: Z3YYX2RBQJTYM
 tasks:
   apache:
     type: https
     image: my-web-app:latest

This will create an externally facing web application for you with
these resources:

=over 4

=item *  A certificate for your domain

=item * A Fargate cluster

=item * IAM roles and policies

=item * A listener and listener rules

=item * A CloudWatch log group

=item * Security groups

=item * A target group

=item * A task definition

=item * An ALB if one is not detected

=back

Once again, launching a Fargate service requires a
lot of fiddling with AWS resources! Getting all of the plumbing
installed and working requires a lot of what and how knowledge.

=head2 Adding or Changing Resources

Adding or updating resources for an existing application should also be
easy. Updating the infrastrucutre should just be a matter of updating
the configuration and re-running the framework's script. When you
update the configuration the script will detect changes and update the
necessary resources.

Currently the framework supports adding a single SQS queue, a single
S3 bucket, volumes using EFS mount points and, environment variables
that can be injected from AWS SecretsManager.

 my-worker:
   image: my-worker:latest
   command: /usr/local/bin/my-worker.pl
   type: task
   schedule: cron(00 15 * * * *)   
   bucket:
     name: my-worker-bucket
   queue:
     name: my-worker-queue
   environment:
     ENVIRONMENT=prod
   secrets:
     db_passord:DB_PASSWORD
   efs:
     id: fs-abcde12355
     path: /
     mount_point: /mnt/my-worker

Adding new resources would normally require you to update your
policies to allow your worker to access these resource. However, the
framework automatically detects that the policy needs to be updated
when new resources are added (even secrets) and takes care of that for
you.

See C<app-Fargate help configuration> for more information about
resources and options.

=head2 Configuration as State

The framework attempts to be as transparent as possible regarding what
it is doing, how long it takes, what the result was and most
importantly I<what defaults were used during resource
provisioning>. Every time the framework is run, the configuration file
is updated based on any new resources provisioned or configured.

This gives you a single view into your Fargate application.

=head1 CLOUDWATCH LOG GROUPS

A CloudWatch log group is automatically provisioned for each
application stack. By default, the log group name is
/ecs/<application-name>, and log streams are created per task.

For example, given the following configuration:

 app:
   name: my-stack
 ...
 tasks:
   apache:
     type: https

The framework will:

=over 4

=item * Create a log group named /ecs/my-stack

=item Configure the apache task to write log streams with a prefix
like my-stack/apache/*

=back

By default, the log group is set to retain logs for 14 days. You can
override this by specifying a custom retention period using the
C<retention_days> key in the task's log_group section:

 log_group:
   retention_days: 30

=head2 Notes

=over 4

=item * The log group is reused if it already exists.

=item * Only numeric values accepted by CloudWatch are valid for
retention_days (e.g., 1, 3, 5, 7, 14, 30, 60, 90, etc.).

=item * You can customize the log group name by setting the name in the C<log_group:> section.

 log_group:
   retention_days: 14
   name: /ecs/my-stack

=back

=head1 IAM PERMISSIONS

This framework uses a single IAM role for all tasks defined within an
application stack.  The assumption is that services within the stack
share a trust boundary and operate on shared infrastructure.  This
simplifies IAM management while maintaining strict isolation between
stacks.

IAM roles and policies are automatically created based on your
configuration.  Only the minimum required permissions are granted.
For example, if your configuration defines an S3 bucket, the ECS task
role will be permitted to access only that specific bucket—not all
buckets in your account.

=head1 SECURITY GROUPS

A security group is automatically provisioned for your Fargate
cluster.  If you define a task of type C<http> or C<https>, the
security group attached to your Application Load Balancer (ALB) is
automatically authorized for ingress to your Fargate task.


=head1 FILESYSTEM SUPPORT

EFS volumes are defined per task and mounted according to the task
definition. This design provides fine-grained control over EFS usage,
rather than treating it as a global, stack-level resource.

Each task that requires EFS support must include both a volume and
mountPoint configuration. The ECS task role is automatically updated
to allow EFS access based on your specification.

To specify EFS support in a task:

 efs:
   id: fs-1234567b
   mount_point: /mnt/my-stack
   path: /
   readonly:

=head2 Field Descriptions

=over 4

=item id:

The ID of an existing EFS filesystem. The framework does not provision
the EFS, but will validate its existence in the current AWS account
and region.

=item mount_point:

The container path to which the EFS volume will be mounted.

=item path:

The path on the EFS filesystem to map to your container's mount point.

=item readonly:

Optional. Set to C<true> to mount the EFS as read-only. Defaults to
C<false>.

=back

=head2 Additional Notes

=over 4

=item * The ECS role's policy for your task is automatically modified
to allow read/write EFS access. Set C<readonly:> in your task's
C<efs:> section to false if only want read support.

=item * Your EFS security group must allow access from private subnets
where the Fargate tasks are placed.

=item * No changes are made to the EFS security group; the framework
assumes access is already configured

=item * Only one EFS volume is currently supported per task configuration.

=item * EFS volumes are task-scoped and reused only where explicitly configured.

=item * The framework does not automatically provision an EFS
filesystem for you. The framework does however validate that the
filesystem exists in the current account and region.

=back

=head1 CONFIGURATION

The C<App::Fargate> framework maintains your application stack's state
using a YAML configuration file. Start the process of building your
stack by creating a YAML file with the minimum required elements.

 app:
   name: my-stack
 tasks:
   my-stack-daemon-1:
     image: my-stack-daemon:latest
     type: daemon

Each service corresponds to a containerized task you wish to
deploy. In this minimal configuration we are provisioning:

=over 4

=item * ...a Fargate cluster in the us-east-1 region 

=item * ...one service that will run a daemon

=item * ...a service that runs in the default VPC in a private
subnet

=item * ...any required resources using the default AWS profile (or the
one specified by the environment variable AWS_PROFILE)

=back

Running C<appFargateStack -c my-stack.yml plan> will analyze your
configuration file and report on the resources about to be created. It
will also update the configuration file with the defaults it used when
discovering the resources that need to be provisioned. You run
C<app-FargateStack -c my-stack.yml apply> to actually build the stack.

=head2 Environment Discovery

If you do not provide some configurtion values C<app-FargateStack>
will inspect your AWS account to automatically set certain
configuration values. For example, if you do not set the C<vpc_id:>
key, the script will look for a default VPC. Your VPC must contain at
least 1 private subnet which will be used to place your Fargate task.

=head2 Configuration Details

The configuration is a YAML formatted file with various elements that
describe your application, its resources and their attributes.  Many
of these elements are optional when you first run the
C<app-FargateStack> script. You must provide at least these sections:

 app:
   name: app-name
 tasks
   image: image-name
   type: daemon|task|http|https

For task type C<http> or C<https> you must also provide a domain name
for your HTTP service.

 domain: domain-name

Configuration schema is show below. All element are optional except
those noted above.

---
account:
alb:
  arn:
  name:
  port:
  type:
app:
  name:
  version:
certificate_arn:
cluster:
  arn:
  name:
default_log_group:
domain:
id:
last_updated:
region:
role:
  arn:
  name:
  policy_name:
route53:
  profile:
  zone_id:
security_groups:
  alb:
    group_id:
    group_name:
  fargate:
    group_id:
    group_name:
subnets:
  private:
  public:
tasks:
  apache:
    arn:
    cpu:
    family:
    image:
    log_group:
      arn:
      name:
      retention_days:
    memory:
    name:
    target_group_arn:
    target_group_name:
    task_definition_arn:
    type:
vpc_id:

=head3 

=head1 ENVIRONMENT VARIABLES

You specify environment variable and their values in the
C<environment:> section of your task's configuration.

Example:

 task:
   apache:
     environment:
       ENVIRONMENT: prod

=head2 Inject Secrets from SecretsManager Into the Environment

To inject secrets from SecretsManager into your environment add a
section name "secrets" to you task's configuration. Specify the path
and environment variable name as C<path:enviroment-variable-name>.

Example:

 secrets:
   /my-stack/mysql-password:DB_PASSWORD

This would inject the secret value for C</my-stack/mysql-password>
into the environment variable "DB_PASSWORD".

=head1 SQS QUEUES

=head2 Customizing Queue Attributes

=head1 S3 BUCKETS

=head2 Adding a Bucket Policy

=head1 SCHEDULED JOBS

=head2 Scheduling A Job

=head2 Running an Adhoc Job

=head1 HTTP SERVICES

=head2 Overview

To create a Fargate HTTP service set the C<type:> key in your task's
configuration section to "http" or "https".

The task type ("http" or "https") determines:

=over 4 

=item *  the B<type of load balancer> that will be used or created

=item * whether a B<certificate will be used or created>

=item * what B<default port> will be configured in your ALB's listener
rule

=head2 Key Assumptions When Creating HTTP Services

=over 4

=item * Your domain is managed in Route 53 and your profile can create
Route 53 record sets.

I<Note: If your domain is managed in a different AWS account, set a
separate `profile` in the `route53:` section with sufficient
permissions to update the relevant hosted zone.>

=item * Your Fargate task will be deployed in a private subnet and
will listen on port 80.

=item * No certificate will be provisioned for internal facing
applications. Traffic by default to internal facing applications
(those that use an internal ALB) will be insecure.

=head2 Architecture

When you set your task type to C<http> or C<https> a default
architecture depicted below will be provisioned.

                            (optional)
                        +------------------+
                        |  Internet Client |
                        +--------+---------+
                                 |
                      [only if ALB is external]
                                 |
                    +------------v--------------+
                    |  Route 53 Hosted Zone     |
                    |  Alias: myapp.example.com |
                    |     --> ALB DNS Name      |
                    +----------+----------------+
                                 |
                      +----------v----------+
                      | Application Load    |
                      | Balancer (ALB)      |
                      | [internal or        |
                      |  internet-facing]   |
                      |                     |
                      | Listeners:          |
                      |   - Port 80         |
                      |   - Port 443 w/ TLS |
                      |     + ACM Cert      |
                      |       (TLS/SSL)     |
                      |     [if external]   |
                      +----------+----------+
                                 |
                          +------v-------+
                          | Target Group |
                          +------+-------+
                                 |
                         +-------v---------+
                         | ECS Service     |
                         | (Fargate Task)  |
                         +-------+---------+
                                 |
                       +---------v----------+
                       | VPC Private Subnet |
                       +--------------------+

This default architecture provides a repeatable, production-ready
deployment pattern for HTTP services with minimal configuration and
robust discovery.

=head2 Behavior by Task Type


For HTTP services, you set the task type to either "http" or "https"
(these are the only options that will trigger a task to be configured
for HTTP services). The table below summarizes the configurations by
task type.

 +-------+----------+-------------+-----------+---------------+
 | Type  | ALB type | Certificate |    Port   |  Hosted Zone  |
 +-------+----------+-------------+-----------+---------------+
 | http  | internal |    No       |    80     |   private     |
 | https | external |   Yes       |   443     |   public      |
 |       |          |             | 80 => 443 |               |
 +-------+----------+-------------+-----------+---------------+

I<NOTE: You must provide a domain name for both an internal and
external facing HTTP service. This also implies you must have a
private hosted zone for internal services and a public hosted zone for
you domain for external services.>

Your task type will also determine where the script looks for an
existing ALB to use (private vs public subnet). If you want to force
the creation of a new ALB use the C<--create-alb> option.

If you do not provide a hosted zone id in your initial configuration,
the framework the framework searches for a hosted zone in Route 53
corresponding to your domain. If the task type is C<https>, the script
looks for a public zone, otherwise it looks for a private zone.

=back

=head2 ACM Certificate Management

If the task type is "https" and no ACM certificate currently exists
for your domain, the framework will automatically provision one. The
certificate will be created in the same region as the ALB and issued
via AWS Certificate Manager. 

If the ALB is internet-facing, the certificate is issued via DNS
validation and automatically attached to the listener on port 443.

=head2 Port and Listener Rules

For external-facing apps, a separate listener on port 80 is
created. It forwards traffic to port 443 using a default redirect rule
(301).

If you want your internal application to listen on a port other than
80, set C<port> to your custom port value in the task's configuration
section. This only changes the container port exposed to the target
group; the listener on the ALB will still forward based on its own
rule.

=back 

=head2 Example Minimal Configuration

 app:
   name: http-test
 domain: http-test.example.com
 task:
   apache:
     type: http
     image: http-test:latest

Based on this minimal configuration C<app-FargateStack> will enrich
the configuration with appropriate defaults and proceed to provision
your HTTP service. In order to do that, the framework attempts to
discover some of the resources required for your service. If your
environment is not compatible with creating the service, the framework
will provide helpful error messages and abort the process.

Given this minimal configuration for an internal ("type: http") or
external ("type: https") HTTP service, discovery entails:

=over 4

=item 1. ...determining your VPC ID

=item 2. ...finding the private subnet IDs

=item 3. ...looking for an existing load balancer

=item 4. ...finding your load balancer's security group (if an ALB exists)

=item 5. ...looking for a listener rule on port 80 (and 443 if "type:
https"), including a default forwarding redirect rule

=item 6. ...looking for a hosted zone in Route 53 that supports your domain

=item 7. ...setting other defaults for other resources to be built (log
groups, cluster, target group, etc)

=item 8. ...determining if an ACM certificate exists for your domain
(type "https" only)

=back

I<Note: Discovery of these resources is only done when they are
missing from your configuration. If you have multiple VPCs for example
you can set C<vpc_id:> in the configuration to identify the target
VPC.  Likewise with other resources like subnets, ALBs, Route 53,
etc. As C<app-FargateStack> finds your resources it fills out the
sections in the configuration giving you complete insight into how it
will provision resources. See L<CONFIGURATION> for complete details on
resource configurations.>

Your environment will be considered valid only if:

=over 4

=item * You have at least 1 private subnet available for deployment

=item * You have a hosted zone for your domain of the appropriate type
(private for type "http", public for type "https")

=back

As discovery progresses, existing and required resources are logged
and updated in the configuration file. If you are NOT running in
dryrun mode, resources will be created immediately as they are
discovered to be missing from your environment.

=head2 Application Load Balancer

When you provision an http service whether or not it is secure we will
place the service behind an application load balancer. Your Fargate
service is created in private subnets, so your VPC must contain at
least one private subnet.  Your load balancer can either be internally
or externally facing. 

By default, the framework looks for a load balancer with the correct
scheme (internal or internet-facing), in a subnet aligned with your
task type, and reuses it if found. Otherwise, a new ALB is
provisioned. When creating a new ALB, C<app-FargateStack> will also
create the necessary listeners for the ports you have configured.

While it is possible to avoid the use or creation of a load balancer
for your service, the framework forces one to be created for two
reasons. Firstly, the IP address of your service may not be stable and
is not friendly for development or production purposes. The framework
is, after all trying its best to grease the wheels and prevent you
from having to think too hard.

Secondly, it is almost guaranteed that you will eventually want to use
a domain name for your production service - whether it is an
internally facing microservice or an externally facing web
application.

Creating an alias in Route 53 for your domain to the ALB ensures you
don't need to update configurations with the service's dynamic IP
address. Additionally, using a load balancer might be useful for
creating custom routing rules to your service and of course for
support traffic management  as you scale your containers.

Therefore the framework's decision was to force the use of ALB and
create an alias record (A) for your domain in AWS for both internal
and external facing services.

=head2 Roadmap for HTTP Services

=over 4

=item * path based routing on ALB listeners

=item * ECS service health check configuration

=item * Auto-scaling policies

=back

=head1 LIMITATIONS

=over 4

=item * Support for only 1 http services

=item * Limited configuration options for some resources

=item * Some out of band infrastructure changes may break the ability
to re-run C<app-FargateStack> without manually updating the
configuration

=item * Support for only 1 EFS filesystem per task

=back

=head1 ROADMAP

=over 4

=item * destroy {task-name}

Destroy all resources for all tasks or for one task. Buckets and
queues will not be deleted.

=item * stop, start services

=item * enable/disable task

=item * health check configuration

=item * scaling configuration

=back

=head1 SEE ALSO

L<IPC::Run>, L<App::Command>, L<App::AWS>, L<CLI::Simple>

=head1 AUTHOR

Rob Lauer - rclauer@gmail.com

=head1 LICENSE

This script is released under the same terms as Perl itself.

=cut
