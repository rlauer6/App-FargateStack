package App::FargateStack;

########################################################################
# Copyright (C) 2025, TBC Development Group, LLC All rights reserved.  #
# This is free software and may be modified or redistributed under the #
# same terms as Perl itself.                                           #
#                                                                      #
# Repository: https://github.com/rlauer6/App-Fargate                   #
########################################################################

use strict;
use warnings;

use App::FargateStack::Builder::Utils qw(jmespath_mapping toCamelCase);
use App::FargateStack::Constants;
use App::FargateStack::Pod;
use CLI::Simple::Constants qw(:booleans :chars %LOG_LEVELS);
use CLI::Simple;
use Carp::Always;
use Carp;
use Data::Dumper;
use Date::Parse qw(str2time);
use English qw(no_match_vars);
use File::Basename qw(basename);
use List::Util qw(none any);
use Log::Log4perl;
use Pod::Usage;
use Scalar::Util qw(reftype looks_like_number);
use Text::ASCIITable::EasyTable;
use Term::ANSIColor;
use YAML qw(LoadFile);

use Role::Tiny::With;

# command methods
with 'App::FargateStack::Init';
with 'App::FargateStack::Logs';
with 'App::FargateStack::Route53';

with 'App::Benchmark';

# builder methods
with 'App::FargateStack::Builder';
with 'App::FargateStack::Builder::IAM';
with 'App::FargateStack::Builder::Certificate';
with 'App::FargateStack::Builder::Events';
with 'App::FargateStack::Builder::EFS';
with 'App::FargateStack::Builder::HTTPService';
with 'App::FargateStack::Builder::Cluster';
with 'App::FargateStack::Builder::LogGroup';
with 'App::FargateStack::Builder::SecurityGroup';
with 'App::FargateStack::Builder::Secrets';
with 'App::FargateStack::Builder::Service';
with 'App::FargateStack::Builder::S3Bucket';
with 'App::FargateStack::Builder::SQSQueue';
with 'App::FargateStack::Builder::TaskDefinition';
with 'App::FargateStack::Builder::Utils';

our $VERSION = '@PACKAGE_VERSION@';

use parent qw(CLI::Simple);

__PACKAGE__->use_log4perl( config => $LOG4PERL_CONF );

caller or __PACKAGE__->main;

########################################################################
sub init_logger {
########################################################################
  my ($self) = @_;

  #  my $log4perl_conf = $LOG4PERL_CONF;

  my $log4perl_conf = $self->get_log4perl_conf;

  if ( !$self->get_color ) {
    $log4perl_conf =~ s/\ColoredLevels//xsm;
  }

  $self->set_log4perl_conf($log4perl_conf);

  return $self->SUPER::init_logger;
}

########################################################################
sub show_config {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  my $subnets = $self->get_subnets;

  $self->log_info( 'init:           account: [%s]', $self->get_account );
  $self->log_info( 'init:           profile: [%s]', $self->get_profile );
  $self->log_info( 'init:    profile source: [%s]', $self->get_profile_source );
  $self->log_info( 'init:            region: [%s]', $self->get_region );
  $self->section_break;

  $self->log_info( 'init:   route53 profile: [%s]', $config->{route53}->{profile} // q{-} );
  $self->log_info( 'init:   route53 zone_id: [%s]', $config->{route53}->{zone_id} // q{-} );
  $self->section_break;

  $self->log_info( 'init:          app name: [%s]', $config->{app}->{name} );
  $self->log_info( 'init:       app version: [%s]', $config->{app}->{version} // q{-} );
  $self->log_info( 'init:     https service: [%s]', $self->get_http           // q{-} );
  $self->log_info( 'init:  scheduled events: [%s]', $self->has_events ? 'yes' : 'no' );
  $self->section_break;

  $self->log_info( 'init:    subnets in VPC: [%s]', $config->{vpc_id} );
  $self->log_info( '                 public: [%s]', join q{,}, @{ $subnets->{public}  || [] } );
  $self->log_info( '                private: [%s]', join q{,}, @{ $subnets->{private} || [] } );
  $self->section_break;

  $self->log_info( 'init:            config: [%s]', $self->get_config_name );
  $self->log_info( 'init:         log level: [%s]', $self->get_log_level // 'info' );
  $self->log_info( 'init:             cache: [%s]', $self->get_cache ? 'enabled' : 'disabled' );
  $self->log_warn( 'init:     update config: [%s]', $self->get_update ? 'yes' : 'no' );
  $self->log_warn( 'init:            dryrun: [%s]', $self->get_dryrun ? 'yes' : 'no' );

  return;
}

########################################################################
sub check_service_name {
########################################################################
  my ( $self, $service_name, $return_on_missing ) = @_;

  my $tasks = $self->common_args('tasks');

  # if only 1 service in config, then let's stat that
  if ( !$service_name ) {
    my ( $default_service, $error ) = grep { $tasks->{$_}->{type} =~ /daemon|http/xsm } keys %{$tasks};

    return
      if !$default_service && $return_on_missing;

    croak sprintf "usage: %s status task-name\n", $ENV{SCRIPT_NAME}
      if $error || !$default_service;

    $service_name = $default_service;
  }

  return $service_name;
}

########################################################################
sub cmd_service_status {
########################################################################
  my ( $self, @args ) = @_;

  my $service_name = $self->check_service_name( @args, $self->get_args );

  my $cluster      = $self->common_args('cluster');
  my $cluster_name = $cluster->{name};

  $self->verify_service( $cluster_name, $service_name );

  require Text::Wrap;
  Text::Wrap->import('wrap');

  {
    ## no critic
    no warnings 'once';
    $Text::Wrap::columns = 100;
  }

  my @elems = qw(running_count desired_count status pending_count events task_definition);

  my $query = jmespath_mapping 'services[0]' => \@elems;

  my $result = $self->get_ecs->describe_services(
    cluster_name => $cluster_name,
    service_name => $service_name,
    query        => $query,
  );

  log_die( $self, "ERROR: could not describe service [%s]\n%s", $service_name, $self->get_ecs->get_error )
    if !$result;

  my ( $running_count, $desired_count, $status, $pending_count, $events, $task_definition )
    = @{$result}{@elems};

  $pending_count //= q{-};

  $status = colored( $status, $status eq 'ACTIVE' ? 'bright_green' : 'bright_yellow' );

  my $title = sprintf "Service:[%s]\n", colored( $service_name, 'bright_white' );
  $title .= sprintf "Status:[%s] Running:[%s] Pending:[%s] Desired:[%s]\n",
    $status, colored( $running_count, 'green' ), colored( $pending_count, 'yellow' ),
    colored( $desired_count, 'bright_white' );
  $title .= sprintf 'Task Definition: [%s]', colored( $task_definition, 'bright_white' );

  my @events = grep {defined} @{ $result->{events} }[ 0 .. ( $self->get_max_events - 1 ) ];

  my @data = map { { 'Time' => $_->{createdAt}, Event => wrap( q{}, q{}, $_->{message} ) } } @events;

  print {*STDOUT} easy_table(
    table_options => { headingText => $title, allowANSI => $TRUE },
    data          => \@data,
    columns       => [qw(Time Event)],
  );

  return $SUCCESS;
}

########################################################################
sub get_default_task_name {
########################################################################
  my ( $self, $type ) = @_;

  my $tasks = $self->common_args('tasks');

  my ($task_name) = $self->get_args;

  $type //= 'task';

  return $task_name
    if $task_name;

  my ( $default_task_name, $err ) = grep { $tasks->{$_}->{type} eq $type } keys %{$tasks};

  return $err ? $EMPTY : $default_task_name;
}

########################################################################
sub cmd_run_task {
########################################################################
  my ($self) = @_;

  my ( $config, $tasks ) = $self->common_args(qw(config tasks));

  my $task_name = $self->get_default_task_name('task');

  croak sprintf "usage: %s run-task task-name\n", $ENV{SCRIPT_NAME}
    if !$task_name;

  my $task = $tasks->{$task_name};

  log_die( $self, "ERROR: no such task [%s] defined in config\n", $task_name )
    if !$task;

  my $subnet_id = $self->get_subnet_id;
  my $is_public = $FALSE;

  if ( !$subnet_id ) {
    my @subnets = @{ $self->get_subnets->{private} // [] };

    if ( !@subnets ) {
      $self->log_warn('run-task: using public subnets is not recommended...');
      @subnets = @{ $self->get_subnets->{public} // [] };
    }

    $subnet_id = $subnets[0];
  }
  elsif ( any { $subnet_id eq $_ } @{ $self->get_subnets->{public} // [] } ) {
    $self->log_error(
      'run-task: subnet-id: [%s] is in a public subnet...consider running your jobs in a private subnet',
      $subnet_id );
    $is_public = $TRUE;
  }
  elsif ( none { $subnet_id eq $_ } @{ $self->get_subnets->{private} // [] } ) {
    log_die( $self, 'subnet: [%s] is not in a public or private subnet in this VPC.', $subnet_id );
  }

  my $network_configuration = {
    awsvpcConfiguration => {
      subnets        => [$subnet_id],
      securityGroups => [ $config->{security_groups}->{fargate}->{group_id} ],
      assignPublicIp => $is_public ? 'ENABLED' : 'DISABLED',
    }
  };

  # check for latest image...
  $self->check_latest_image($task_name);

  my $cluster_name = $config->{cluster}->{name};

  $self->log_warn( 'run-task: cluster: [%s] launching task: [%s] in subnet: [%s]',
    $cluster_name, $task_name, $subnet_id );

  my $result = $self->get_ecs->run_task(
    cluster               => $cluster_name,
    task_definition       => $task_name,
    network_configuration => $network_configuration,
  );

  log_die( $self, "ERROR: could not run task [%s]\n%s\n", $task_name, $self->get_ecs->get_error )
    if !$result;

  my @failures = @{ $result->{failures} };

  log_die( $self, 'ERROR: task failed to launch: %s', Dumper( \@failures ) )
    if @failures;

  ($tasks) = @{ $result->{tasks} };

  my $task_arn = $tasks->{taskArn};

  my $should_wait = $self->get_wait ? '(waiting)' : $EMPTY;

  $self->log_warn( 'run-task: task [%s] launched. ARN: [%s]...%s', $task_name, $task_arn, $should_wait );

  my $poll_limit = $self->get_task_timeout / $DEFAULT_ECS_POLL_TIME;

  if ($should_wait) {
    my $poll_count = 0;

    while ( $poll_count++ < $poll_limit ) {

      my ( $status, $stopped_reason, $exit_code ) = $self->get_task_status( $cluster_name, $task_arn );

      $self->log_warn( 'run-task: task [%s] status: [%s], exit code:[%s], reason: [%s]',
        $task_name, map { $_ // q{-} } ( $status, $exit_code, $stopped_reason ) );

      last if $status eq 'STOPPED';

      sleep $DEFAULT_ECS_POLL_TIME;
    }

    my $log_group = $config->{tasks}->{$task_name}->{log_group}->{name};

    # by convention our log groups are named after our app
    my $log_stream = sprintf '%s/%s/%s', $config->{app}->{name}, $task_name, ( split /\//xsm, $task_arn )[-1];

    require App::Logs;

    my $logs = App::Logs->new(
      %{ $self->get_global_options },
      log_group_name  => $log_group,
      log_stream_name => $log_stream
    );

    my $events = $logs->get_log_events();

    log_die( $self, "run-task: unable to get logs from log group: [%s], stream: [%s]\n%s",
      $log_group, $log_stream, $logs->get_error )
      if !$events;

    while ( $events && @{ $events->{events} } ) {

      foreach my $e ( @{ $events->{events} } ) {

        my ( $timestamp, $message ) = @{$e}{qw(timestamp message)};
        $timestamp = scalar localtime $timestamp / 1000;

        print {*STDOUT} sprintf "%s - %s\n", $timestamp, $message;
      }

      $events = $logs->get_next_log_events( $events->{nextForwardToken} );
    }
  }

  return $SUCCESS;
}

########################################################################
sub check_latest_image {
########################################################################
  my ( $self, $task_name ) = @_;

  my $tasks = $self->common_args('tasks');

  my $latest_image   = $self->get_latest_image($task_name);
  my $latest_digest  = $latest_image->{imageDigest};
  my $current_digest = $tasks->{$task_name}->{image_digest} // $EMPTY;

  if ( $current_digest ne $latest_digest ) {
    $self->log_error('run-task: You are not running the latest image!');
    $self->log_error( 'run-task: [%s] != [%s]', $latest_digest, $current_digest );
    $self->log_error('run-task: Run "app-Fargate register-task" to align the latest image with your task');

    log_die( $self, 'run-task: use --force to force run or align our task with new image' )
      if !$self->get_force;
  }

  return;
}

########################################################################
sub get_task_status {
########################################################################
  my ( $self, $cluster_name, $task_arn ) = @_;

  my @elems = qw(last_status stopped_reason containers);

  my $query = jmespath_mapping 'tasks[0]' => \@elems;

  my $result = $self->get_ecs->describe_tasks( $cluster_name, $task_arn, $query );

  croak sprintf "ERROR: unable to describe task: [%s]\n%s", $task_arn, $self->get_ecs->get_error
    if !$result;

  my ( $status, $stopped_reason, $containers ) = @{$result}{@elems};

  return ( $status, $stopped_reason, $containers->[0]->{exitCode} );
}

########################################################################
sub get_default_service_name {
########################################################################
  my ($self) = @_;

  my ($service_name) = $self->get_args;

  return $service_name
    if $service_name;

  my @service_names;

  foreach (qw(http https daemon)) {
    my $service_name = $self->get_default_task_name($_);
    next if !$service_name;
    push @service_names, $service_name;
  }

  return @service_names;
}

########################################################################
sub cmd_create_service {
########################################################################
  my ($self) = @_;

  my ( $task_name, $err ) = $self->get_default_service_name();

  croak sprintf "usage: %s create-service service-name\n", $ENV{SCRIPT_NAME}
    if !$task_name || $err;

  my ( $config, $tasks ) = $self->common_args(qw(config tasks));

  log_die( $self, sprintf "usage: %s create-service task-name\n", $ENV{SCRIPT_NAME} )
    if !$task_name;

  log_die( $self, "no such task defined in config [%s]\n", $task_name )
    if !$tasks->{$task_name};

  $self->log_info('service: checking to see if task and latest image are aligned...');

  $self->check_latest_image($task_name);

  return $self->build_service($task_name);
}

########################################################################
sub check_task {
########################################################################
  my ( $self, $task_name, $warn ) = @_;

  my $level = $warn ? 'warn' : 'die';

  my $config = $self->get_config;

  return $TRUE
    if $task_name && $config->{tasks}->{$task_name};

  log_die( $self, 'ERROR:  no such task [%s] defined in config', $task_name )
    if $level eq 'die';

  $self->get_logger->warn( 'WARNING: no such task [%s] defined in config...trying anyway  ¯\_(ツ)_/¯',
    $task_name );

  return;
}

########################################################################
sub cmd_delete_service {
########################################################################
  my ($self) = @_;

  my ( $task_name, $err ) = $self->get_default_service_name();

  croak "usage: %s delete-service task-name\n", $ENV{SCRIPT_NAME}
    if !$task_name || $err;

  my ( $config, $cluster ) = $self->common_args(qw(config cluster));

  my $cluster_name = $cluster->{name};

  $self->verify_service( $cluster_name, $task_name );

  $self->check_task( $task_name, 'warn' );

  my $ecs = $self->get_ecs;

  my $result = $ecs->delete_service( $cluster->{name}, $task_name );

  log_die( $self, "ERROR: could not stop service %s\n%s", $task_name, $ecs->get_error )
    if $ecs->get_error;

  return $SUCCESS;
}

########################################################################
sub verify_service {
########################################################################
  my ( $self, $cluster_name, $service_name ) = @_;

  my $ecs = $self->get_ecs;

  my $services = $ecs->list_services( $cluster_name, 'serviceArns' );

  croak sprintf "ERROR: could not list services for cluster: [%s]\n%s", $cluster_name, $ecs->get_error
    if !$services;

  croak sprintf "ERROR: no services running in cluster: [%s]\n", $cluster_name
    if !@{$services};

  croak sprintf "ERROR: service [%s] is not running in cluster: [%s]\n", $service_name, $cluster_name
    if none { $_ =~ /$service_name/xsm } @{$services};

  return;
}

########################################################################
sub update_task_count {
########################################################################
  my ( $self, $task_name, $desired_count ) = @_;

  my ( $config, $cluster ) = $self->common_args(qw(config cluster));

  my $cluster_name = $cluster->{name};

  $self->verify_service( $cluster_name, $task_name );

  my $ecs = $self->get_ecs;

  my $result = $ecs->update_service(
    cluster_name  => $cluster_name,
    desired_count => $desired_count,
    service_name  => $task_name,
  );

  log_die( $self, "ERROR: could not update service: [%s]\n%s", $task_name, $ecs->get_error )
    if !$result;

  return $result;
}

########################################################################
sub cmd_update_service {
########################################################################
  my ($self) = @_;

  my ( $task_name, $count ) = $self->get_args;

  if ( looks_like_number $task_name ) {
    $count     = $task_name;
    $task_name = $EMPTY;
  }

  $task_name = $self->check_service_name($task_name);

  if ( $self->command eq 'start-service' ) {
    $count ||= 1;
  }
  else {
    $count = 0;
  }

  if ( !$task_name ) {
    if ( $count == 0 ) {
      croak sprintf "usage: %s -c config-name stop-service task-name\n", $ENV{SCRIPT_NAME};
    }

    croak sprintf "usage: %s -c config-name start-service task-name [count]\n", $ENV{SCRIPT_NAME};
  }

  my $result = $self->update_task_count( $task_name, $count );

  sleep 2;  # wait a few seconds for status to be updated

  return $self->cmd_service_status($task_name);
}

########################################################################
sub cmd_register {
########################################################################
  my ($self) = @_;

  my ( $config, $tasks, $dryrun ) = $self->common_args(qw(config tasks dryrun));

  my $task_name = $self->get_default_task_name;

  my $action = $self->get_skip_register ? 'update-target' : 'register';

  log_die( $self, 'usage: %s %s task-name', $action, $ENV{SCRIPT_NAME} )
    if !$task_name;

  my $ecs = $self->get_ecs;

  my $task_definition_file = sprintf 'taskdef-%s.json', $task_name;

  $self->check_task($task_name);

  log_die( $self, "ERROR: no task definition file found for %s\n", $task_name )
    if !-s $task_definition_file;

  my $task_definition_arn;

  if ( !$self->get_skip_register ) {
    $self->log_warn( 'register: registering [%s]...%s', $task_name, $dryrun );

    if ( !$dryrun ) {
      my $task_definition = $ecs->register_task_definition($task_definition_file);

      log_die( $self, 'register: could not register [%s]\n%s', $task_definition_file, $ecs->get_error )
        if !$task_definition;

      $self->log_trace( sub { return Dumper( [ task_definition => $task_definition ] ) } );

      $task_definition_arn = $task_definition->{taskDefinition}->{taskDefinitionArn};

      log_die(
        $self,
        'register: no taskDefinitionArn found? %s',
        Dumper( [ task_definition => $task_definition ] )
      ) if !$task_definition_arn;

      $self->log_warn( 'register: registered...[%s]', $task_definition_arn );

      $tasks->{$task_name}->{arn} = $task_definition_arn;

      my $latest_image = $self->get_latest_image($task_name);

      $self->log_info( 'register: updating image digest: [%s]', $latest_image->{imageDigest} );
      $tasks->{$task_name}->{image_digest} = $latest_image->{imageDigest};

      $self->update_config;  # record new task definition arn
    }
  }

  ## - events -
  if ( $tasks->{$task_name}->{type} eq 'task' ) {
    require App::Events;

    my $event = App::Events->new( $self->get_global_options );

    my $rule_name = sprintf '%s-schedule', $task_name;

    my $target = $event->list_targets_by_rule( $rule_name, 'Targets' );

    if ( $target && @{$target} ) {

      # we only need to update the config if we skipped
      # registration...this is to allow for updating an event target
      # with a new task definition manually
      if ( !$dryrun && $self->get_skip_register ) {
        $config->{tasks}->{$task_name}->{arn} = $task_definition_arn;
        $self->update_config;
      }

      $self->create_event_target($task_name);
    }
  }

  return $SUCCESS;
}

########################################################################
sub get_latest_image {
########################################################################
  my ( $self, $task_name ) = @_;

  my $tasks = $self->common_args('tasks');

  require App::ECR;

  my $ecr = App::ECR->new( $self->get_global_options );

  my ($repo_name) = split /:/xsm, $tasks->{$task_name}->{image};

  my ($latest) = $ecr->get_latest_image($repo_name);

  return $latest;
}

########################################################################
sub cmd_explain {
########################################################################
  my ($self) = @_;

  my $config = $self->get_config;

  return $SUCCESS;
}

########################################################################
sub cmd_version {
########################################################################

  my $version_stmt = <<'END_OF_TEXT';
%s %s
Copyright 2025 (c) TBC Development Group, LLC.

License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
END_OF_TEXT

  my $pgm = $ENV{SCRIPT_NAME} // $PROGRAM_NAME;

  print {*STDOUT} sprintf $version_stmt, $pgm, $VERSION;

  return $SUCCESS;
}

########################################################################
sub cmd_plan {
########################################################################
  my ( $self, @args ) = @_;

  $self->set_dryrun('(dryrun)');

  return $self->build(@args);
}

########################################################################
sub cmd_apply {
########################################################################
  my ( $self, @args ) = @_;

  $self->set_dryrun($EMPTY);

  return $self->build(@args);
}

########################################################################
sub cmd_update_target {
########################################################################
  my ( $self, @args ) = @_;

  $self->set_skip_register($TRUE);

  return $self->cmd_register(@args);
}

########################################################################
sub cmd_stop_task {
########################################################################
  my ( $self, @args ) = @_;

  my ( $config, $tasks ) = $self->common_args(qw(config tasks));

  my ($task_id) = $self->get_args;

  my ($task_name) = $self->check_service_name( $task_id, $TRUE );

  if ($task_name) {
    $task_id = $tasks->{$task_name}->{arn};
  }

  my $ecs = $self->get_ecs;

  croak sprintf "usage: %s stop-task task-name|task-id|task-arn\n", $ENV{SCRIPT_NAME}
    if none { length $task_id == $_ } ( 32, 36 );

  my $result = $ecs->stop_task( $config->{cluster}->{name}, $task_id );

  log_die( $self, "ERROR: could not stop task: [%s]\n%s", $task_id, $ecs->get_error )
    if !$result;

  return $SUCCESS;
}

########################################################################
sub cmd_list_tasks {
########################################################################
  my ( $self, @args ) = @_;

  my $config = $self->get_config;

  my $cluster_name = $config->{cluster}->{name};

  my $ecs = $self->get_ecs;

  my $result = $ecs->list_tasks( $cluster_name, 'taskArns' );

  croak sprintf "ERROR: could not list tasks for cluster: [%s]\n%s", $cluster_name, $ecs->get_error
    if !$result;

  if ( !@{$result} ) {
    print {*STDERR} sprintf "No tasks currently running in cluster: [%s]\n", $cluster_name;

    return $SUCCESS;
  }

  my @task_ids  = map { basename $_ } @{$result};
  my $task_list = join q{ }, @task_ids;

  my @elems = qw(status task_definition_arn last_status started_at memory cpu attachments task_arn);

  my $query = jmespath_mapping 'task[]' => \@elems;

  $result = $ecs->describe_tasks( $cluster_name, $task_list, $query );

  croak sprintf "ERROR: could not list describe tasks: [%s]\n%s", $cluster_name, $ecs->get_error
    if !$result;

  my $title = sprintf 'Tasks (cluster: %s)', $cluster_name;

  my @data;

  foreach ( @{$result} ) {
    my ( $status, $last_status, $start_time, $memory, $cpu, $arn )
      = @{$_}{qw(status last_status started_at memory cpu task_arn)};
    my $task_name = basename( $_->{task_definition_arn} );
    $task_name =~ s/:\d+$//;

    push @data,
      {
      'Start Time'   => $start_time,
      Status         => $status // $last_status,
      Memory         => $memory,
      CPU            => $cpu,
      'Task Id'      => basename($arn),
      'Task Name'    => $task_name,
      'Elapsed Time' => elapsed_time($start_time),
      };
  }

  print {*STDOUT} easy_table(
    table_options => { headingText => $title },
    data          => \@data,
    columns       => [ 'Task Name', 'Task Id', 'Status', 'Memory', 'CPU', 'Start Time', 'Elapsed Time' ],
  );

  return $SUCCESS;
}

########################################################################
sub cmd_enable_scheduled_task {
########################################################################
  my ($self) = @_;

  return $self->update_rule_state($TRUE);
}

########################################################################
sub cmd_disable_scheduled_task {
########################################################################
  my ( $self, @args ) = @_;

  return $self->update_rule_state($FALSE);
}

########################################################################
sub cmd_update_policy {
########################################################################
  my ( $self, @args ) = @_;

  $self->set_cache($FALSE);

  return $self->build(@args);
}

########################################################################
sub cmd_ {
########################################################################
  my ( $self, @args ) = @_;

  return $SUCCESS;
}

########################################################################
sub cmd_redeploy {
########################################################################
  my ( $self, @args ) = @_;

  my $cluster      = $self->common_args('cluster');
  my $cluster_name = $cluster->{name};

  my ( $service_name, $err ) = $self->get_default_service_name;

  croak sprintf "usage: %s redeploy service-name\n", $ENV{SCRIPT_NAME}
    if !$service_name || $err;

  my $ecs = $self->get_ecs;

  my $result = $ecs->update_service(
    cluster_name => $cluster_name,
    service_name => $service_name,
    force        => $TRUE
  );

  log_die( $self, "ERROR: could not update service: [%s]\n%s", $service_name, $ecs->get_error )
    if !$result;

  $self->log_info( 'redeploy: successfully updated service: [%s]', $service_name );

  return $SUCCESS;
}

########################################################################
sub cmd_reset_history {
########################################################################
  my ( $self, @args ) = @_;

  $self->fetch_option_defaults($TRUE);

  return $SUCCESS;
}

########################################################################
sub fetch_option_defaults {
########################################################################
  my ( $self, $reset ) = @_;

  my $options = {};

  my $defaults_file = '.fargatestack/defaults.json';

  if ( -s $defaults_file ) {
    $options = slurp_file( $defaults_file, $TRUE );
  }
  else {
    mkdir '.fargatestack';
  }

  return $self->write_json_file( $defaults_file, {} )
    if $reset;

  $options->{profile}         = $self->get_profile         // $options->{profile};
  $options->{config}          = $self->get_config          // $options->{config};
  $options->{region}          = $self->get_region          // $options->{region};
  $options->{route53_profile} = $self->get_route53_profile // $options->{route53_profile};
  $options->{max_events}      = $self->get_max_events      // $options->{max_events};

  $self->set_profile( $options->{profile} );
  $self->set_config( $options->{config} );
  $self->set_region( $options->{region} );
  $self->set_route53_profile( $options->{route53_profile} );
  $self->set_max_events( $options->{max_events} );

  $self->write_json_file( $defaults_file, $options );

  return $options;
}

########################################################################
sub help {
########################################################################
  my ($self) = @_;

  my $subject = lc join $SPACE, @ARGV;
  $subject =~ s/\s+$//xsm;

  my $section = $HELP_SUBJECTS{$subject} // $EMPTY;

  if ( $subject && !$section && $subject ne 'help' ) {
    my @possible_subjects = grep {/$subject/xsmi} keys %HELP_SUBJECTS;

    if ( @possible_subjects == 1 ) {
      $section = $HELP_SUBJECTS{ $possible_subjects[0] };
    }
    elsif (@possible_subjects) {
      print {*STDERR} sprintf "'%s' was not found in the help index.\n\nPossible matches:\n\t* %s\n", $subject,
        join "\n\t* ",
        @possible_subjects;
      exit 1;
    }
  }

  if ( $section && ref $section ) {
    $section = $section->[0];
  }
  elsif ($section) {  # a help subject alias
    my $reference = $HELP_SUBJECTS{$section};
    $section = $reference->[0];
  }

  eval {
    require IO::Pager;
    IO::Pager::open( *STDOUT, '|-:utf8', 'Unbuffered' );
  };

  if ( $subject && !$section ) {
    if ( $subject ne 'help' ) {
      print {*STDERR} sprintf "'%s' is not a valid subject\n", $subject;
    }

    my @data;

    foreach my $keyword ( sort keys %HELP_SUBJECTS ) {
      my $description = $HELP_SUBJECTS{$keyword};
      if ( ref $description ) {
        $description = $description->[1];
      }
      push @data, { Keyword => $keyword, Description => $description };
    }

    my $table = easy_table(
      columns       => [qw(Keyword Description)],
      data          => \@data,
      table_options => { headingText => 'Help Subjects' },
    );

    print {*STDOUT} $table;

    exit $SUCCESS;
  }

  return pod2usage(
    -input   => $INC{'App/FargateStack/Pod.pm'},
    -exitval => 1,
    -verbose => 99,
    $section ? ( -sections => uc $section // 'USAGE' ) : ()
  );
}

########################################################################
sub main {
########################################################################

  my @extra_options = qw(
    account
    alb
    config_name
    ec2
    ecs
    efs
    elb
    events
    existing_resources
    http
    iam
    global_options
    logs
    log_groups
    logger
    profile_source
    required_resources
    route53
    sts
    secrets
    subnets
    taskdef_status
  );

  my @option_specs = qw(
    help|h
    config|c=s
    color!
    create-alb|C
    dryrun|d
    force|f
    log-level=s
    log-time!
    log-wait!
    log-poll-time=s
    history|H!
    max-events|m=i
    profile|p=s
    region|r=s
    route53-profile|R=s
    skip-register|s
    subnet-id=s
    task-timeout|t
    update|u!
    unlink|U!
    cache!
    version|v
    wait|w!
  );

  my %default_options = (
    wait            => $TRUE,
    unlink          => $TRUE,
    color           => $TRUE,
    cache           => $TRUE,
    'log-time'      => $TRUE,
    'log-wait'      => $TRUE,
    'log-poll-time' => $DEFAULT_LOG_POLL_TIME,
    'task-timeout'  => $DEFAULT_ECS_POLL_LIMIT,
    history         => $TRUE,
    update          => $TRUE,
    'max-events'    => 5,
  );

  my %commands = (
    'create-service'         => [ \&cmd_create_service, 'error' ],
    'delete-service'         => [ \&cmd_delete_service, 'error' ],
    'disable-scheduled-task' => \&cmd_disable_scheduled_task,
    'enable-scheduled-task'  => \&cmd_enable_scheduled_task,
    'list-tasks'             => [ \&cmd_list_tasks,    'error' ],
    'list-zones'             => [ \&cmd_list_zones,    'error' ],
    'reset-history'          => [ \&cmd_reset_history, 'info', { init => $FALSE } ],
    'run-task'               => \&cmd_run_task,
    'start-service'          => [ \&cmd_update_service, 'error' ],
    'stop-service'           => [ \&cmd_update_service, 'error' ],
    'stop-task'              => [ \&cmd_stop_task,      'error' ],
    'update-policy'          => \&cmd_update_policy,
    'update-target'          => \&cmd_update_target,
    apply                    => \&cmd_apply,
    default                  => [ \&cmd_explain, 'error' ],
    help                     => [ \&help,        'error', { init => $FALSE } ],
    logs                     => [ \&cmd_logs,    'error' ],
    plan                     => \&cmd_plan,
    redeploy                 => \&cmd_redeploy,
    register                 => \&cmd_register,
    status                   => [ \&cmd_service_status, 'error' ],
    version                  => [ \&cmd_version, 'error', { init => $FALSE } ],
  );

  my $fargate_stack = App::FargateStack->new(
    commands        => \%commands,
    default_options => \%default_options,
    extra_options   => \@extra_options,
    option_specs    => \@option_specs,
    abbreviations   => $TRUE,
  );

  $fargate_stack->run();

  return 0;
}

1;

__END__
